<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<title>Loop (Dateien &amp; Ordner)</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<link href="../css/default.css" rel="stylesheet" type="text/css">
</head>
<body>

<h1>Loop (Dateien &amp; Ordner)</h1>

<p>Ermittelt nacheinander die angegebenen Dateien oder Ordner.</p>

<pre class="Syntax">Loop, Files, FilePattern [, Mode] </pre>
<h3>Parameter</h3>
<dl>

  <dt>Files</dt>
  <dd><p>This parameter must be the word FILES, and cannot be an expression or variable reference.</p></dd>

  <dt>Dateimuster</dt>
  <dd><p>Name einer Datei, eines Ordners oder einer musterbasierten Suche wie C:\Temp\*.tmp. <em>Dateimuster</em> befindet sich im <a href="../Variables.htm#WorkingDir">A_WorkingDir</a>-Verzeichnis, solange kein absoluter Pfad angegeben ist.</p>
    <p>Sowohl Sternchen als auch Fragezeichen werden als Platzhalter unterstützt. Eine Übereinstimmung erfolgt, wenn das Muster mit dem langen/normalen oder <a href="#LoopFileShortName">8.3-kurzen Dateinamen</a> übereinstimmt.</p>
    <p>Wenn dieser Parameter eine Datei oder einen Ordner enthält (also ohne Platzhalter) und <em>Rekursiv</em> auf 1 gesetzt ist, werden mehrere Übereinstimmungen gefunden, sobald der angegebene Dateiname in mehreren Ordnern vorkommt.</p></dd>

  <dt>Modus</dt>
  <dd><p>One or more of the following characters (case-insensitive), optionally separated by spaces or tabs:</p>
      <p><strong>F</strong>: Retrieve <em>files</em> which match the pattern. This is the default if "D" is not specified.<br>
      <strong>D</strong>: Retrieve folders (<em>directories</em>) which match the pattern.<br>
      <strong>R</strong>: <em>Recurse</em> into subfolders so that files and folders contained therein are retrieved if they match FilePattern. All subfolders will be recursed into, not just those whose names match FilePattern.</p></dd>

</dl>

<h3>Spezielle Variablen innerhalb einer Datei-Schleife</h3>
<p>Folgende Variablen existieren innerhalb einer dateilesenden Schleife. Wenn eine innere Datei-Schleife von einer äußeren Datei-Schleife umschlossen ist, hat die Datei von der innersten Schleife Vorrang.</p>
<table class="info">
  <tr>
    <td>A_LoopFileName</td>
    <td><a name="LoopFileName" id="LoopFileName"></a>Der aktuell ermittelte Datei- oder Ordnername (ohne Pfad).</td>
  </tr>
  <tr>
    <td><a name="LoopFileExt"></a>A_LoopFileExt</td>
    <td>Die Dateierweiterung (z. B. TXT, DOC oder EXE). Der Punkt (.) ist nicht inbegriffen.</td>
  </tr>
  <tr>
    <td>A_LoopFilePath</td>
    <td><a name="LoopFilePath"></a>Der Pfad und Name von Dateien oder Ordnern, die gerade abgerufen werden. Wenn <em>Dateimuster</em> anstelle eines absoluten Pfads einen relativen Pfad enthält, ist dieser Pfad hier auch relativ. Darüber hinaus werden kurze (8.3) Ordnernamen in <em>Dateimuster</em> weiterhin kurz sein (siehe nächsten Punkt, um die lange Version zu erhalten). </td>
  </tr>
  <tr>
    <td>A_LoopFileFullPath</td>
    <td><a name="LoopFileFullPath"></a>This is different than A_LoopFilePath in the following ways: 1) Sie enthält immer den absoluten/kompletten Pfad der Datei, auch dann, wenn <em>Dateimuster</em> einen relativen Pfad enthält; 2) Jeder kurze (8.3) Ordnername in <em>Dateimuster</em> wird in einem langen Namen umgewandelt; 3) Die Zeichen in <em>Dateimuster</em> werden an die Groß- oder Kleinschreibung angepasst, wie sie aktuell im Dateisystem gespeichert sind. Das ist nützlich, um Dateinamen (die zum Beispiel als Befehlszeilenparameter übergeben wurden) in ihre exakten Pfadnamen umzuwandeln, wie sie vom Explorer angezeigt werden.</td>
  </tr>
  <tr>
    <td>A_LoopFileShortPath</td>
    <td><p><a name="LoopFileShortPath"></a>Der aktuell ermittelte Datei- oder Ordnername mit Pfad im 8.3-Format. Zum Beispiel: C:\EIGENE~1\ADRESS~1.TXT. Wenn <em>Dateimuster</em> anstelle eines absoluten Pfads einen relativen Pfad enthält, ist dieser Pfad hier auch relativ.</p>
      <p>Um den kompletten Pfad und Namen im 8.3-Format von einer einzelnen Datei oder Ordners abzurufen, muss deren Name wie folgt in <em>Dateimuster</em> angegeben werden:</p>
<pre>Loop, Files, C:\My Documents\Address List.txt
    ShortPathName := A_LoopFileShortPath</pre>
        <p>HINWEIS: Diese Variable wird <strong>leer</strong> sein, wenn die Datei keinen kurzen Namen hat. Das passiert zum Beispiel, wenn NtfsDisable8dot3NameCreation in der Registrierung vorhanden ist. Sie ist auch leer, wenn Dateimuster einen relativen Pfad enthält und der Schleifenkörper <a href="SetWorkingDir.htm">SetWorkingDir</a> verwendet, um vom eigentlichen Arbeitsverzeichnis der Schleife selbst wegzuschalten.</p></td>
  </tr>
  <tr>
    <td>A_LoopFileShortName</td>
    <td><a name="LoopFileShortName"></a>Der 8.3-Kurzname, oder alternative Name der Datei. Falls die Datei keinen Kurznamen hat (weil der lange Name kürzer als der 8.3-Name ist oder die Kurznamengenerierung auf einem NTFS-Dateisystem deaktiviert ist), wird stattdessen <em>A_LoopFileName</em> abgerufen. </td>
  </tr>
  <tr>
    <td>A_LoopFileDir</td>
    <td><a name="LoopFileDir"></a>Der Pfad des Verzeichnisses, in der sich <em>A_LoopFileName</em> befindet. Wenn <em>Dateimuster</em> anstelle eines absoluten Pfads einen relativen Pfad enthält, dann ist dieser Pfad hier auch relativ. Ein Hauptverzeichnis wird keinen nachfolgenden Backslash enthalten. Zum Beispiel: C:</td>
  </tr>
  <tr>
    <td>A_LoopFileTimeModified</td>
    <td><a name="LoopFileTimeModified"></a>Wann die Datei zuletzt bearbeitet wurde. <a href="FileSetTime.htm">YYYYMMDDHH24MISS</a>-Format.</td>
  </tr>
  <tr>
    <td>A_LoopFileTimeCreated</td>
    <td><a name="LoopFileTimeCreated"></a>Wann die Datei erstellt wurde. <a href="FileSetTime.htm">YYYYMMDDHH24MISS</a>-Format.</td>
  </tr>
  <tr>
    <td>A_LoopFileTimeAccessed</td>
    <td><a name="LoopFileTimeAccessed"></a>Wann die Datei zuletzt aufgerufen wurde. <a href="FileSetTime.htm">YYYYMMDDHH24MISS</a>-Format.</td>
  </tr>
  <tr>
    <td>A_LoopFileAttrib</td>
    <td><a name="LoopFileAttrib"></a>Die <a href="FileGetAttrib.htm">Attribute</a> der aktuell ermittelten Datei.</td>
  </tr>
  <tr>
    <td>A_LoopFileSize</td>
    <td><a name="LoopFileSize"></a>Die Größe in Bytes der aktuell ermittelten Datei. Dateien größer als 4 Gigabyte werden ebenfalls unterstützt.</td>
  </tr>
  <tr>
    <td>A_LoopFileSizeKB</td>
    <td><a name="LoopFileSizeKB"></a>Die Größe in Kilobytes der aktuell ermittelten Datei, abgerundet auf den nächsten Integer. </td>
  </tr>
  <tr>
    <td>A_LoopFileSizeMB</td>
    <td><a name="LoopFileSizeMB"></a>Die Größe in Megabytes der aktuell ermittelten Datei, abgerundet auf den nächsten Integer. </td>
  </tr>
</table>
<h3>Bemerkungen</h3>
<p>Eine Datei-Schleife ist nützlich, wenn mehrere Dateien und/oder Ordner nacheinander bearbeitet werden sollen.</p>
<p>Alle übereinstimmenden Dateien werden ermittelt, einschließlich versteckte Dateien. OS-Funktionen wie der DIR-Befehl lassen hingegen versteckte Dateien standardmäßig weg. Um die Bearbeitung von versteckten, schreibgeschützten und/oder System-Dateien zu vermeiden, kann folgendes Beispiel innerhalb der Schleife verwendet werden:</p>
<pre>If A_LoopFileAttrib contains H,R,S  <em>; Jede Datei überspringen, die H (versteckt), R (schreibgeschützt) oder S (vom System) ist. Hinweis: Keine Leerzeichen in "H,R,S".</em>
    continue  <em>; Diese Datei überspringen und zur Nächsten gehen</em></pre>
<p>To retrieve files' relative paths instead of absolute paths during a recursive search, use <a href="SetWorkingDir.htm">SetWorkingDir</a> to change to the base folder prior to the loop, and then omit the path from the Loop (e.g. Loop, *.*, 0, 1). That will cause <a href="#LoopFilePath">A_LoopFilePath</a> to contain the file's path relative to the base folder.</p>
<p>Eine Datei-Schleife kann sich selbst unterbrechen, wenn sie Dateien oder Ordner innerhalb der eigenen Zuständigkeit erstellt oder umbenennt. Wenn die Dateien in der Schleife zum Beispiel mit <a href="FileMove.htm">FileMove</a> umbenannt werden, kann es passieren, dass diese jeweils zweimal gefunden werden: einmal mit dem alten Namen und nochmal mit dem neuen Namen. Als Übergangslösung sollten die Dateien nur umbenannt werden, nachdem eine Liste von denen erstellt wurde. Zum Beispiel:</p>
<pre>FileList := ""
Loop Files, *.jpg
   FileList .= A_LoopFileName "`n"
Loop Parse, %FileList%, `n
   FileMove, %A_LoopField%, renamed_%A_LoopField%</pre>
<p>Dateien in einem NTFS-Dateisystem werden wahrscheinlich immer in alphabetischer Reihenfolge abgerufen. Dateien in anderen Dateisystemen werden in keiner bestimmten Reihenfolge abgerufen. Um eine bestimmte Reihenfolge sicherzustellen, sollte der <a href="Sort.htm">Sort</a>-Befehl verwendet werden, wie unten im Abschnitt "Beispiele" gezeigt.</p>
<p>Dateien und Ordner mit einem kompletten Pfad länger als 259 Zeichen werden ignoriert, als würde sie nicht existieren. Solche Dateien sind normalerweise selten, weil das Betriebssystem nicht erlaubt, dass diese erstellt werden können.</p>
<p>Auf der <a href="Loop.htm">Loop</a>-Seite können Informationen zu <a href="Block.htm">Blöcke</a>, <a href="Break.htm">Break</a>, <a href="Continue.htm">Continue</a> und A_Index gefunden werden (weil diese in jeder Schleifenvariante vorkommen).</p>
<h3>Siehe auch</h3>
<p><a href="Loop.htm">Loop</a>, <a href="Break.htm">Break</a>, <a href="Continue.htm">Continue</a>, <a href="Block.htm">Blöcke</a>, <a href="SplitPath.htm">SplitPath</a>, <a href="FileSetAttrib.htm">FileSetAttrib</a>, <a href="FileSetTime.htm">FileSetTime</a></p>
<h3>Beispiele</h3>
<pre class="NoIndent"><em>; Example #1:</em>
Loop, Files, %A_ProgramFiles%\*.txt, R  <em>; Recurse into subfolders.</em>
{
    MsgBox, 4, , Filename = %A_LoopFilePath%`n`nContinue?
    if A_MsgBoxResult = "No"
        break
}</pre>
<p>&nbsp;</p>
<pre class="NoIndent"><em>; Beispiel #2: Calculate the size of a folder, including the files in all its subfolders:</em>
FolderSizeKB := 0
DirSelect, WhichFolder  <em>; Ask the user to pick a folder.</em>
Loop, Files, %WhichFolder%\*.*, R
    FolderSizeKB += A_LoopFileSizeKB
MsgBox Size of %WhichFolder% is %FolderSizeKB% KB.</pre>
<p>&nbsp;</p>
<pre class="NoIndent"><em>; Beispiel #3: Retrieve file names sorted by name (see next example to sort by date):</em>
FileList := ""  <em>; Initialize to be blank.</em>
Loop, Files, C:\*.*
    FileList .= A_LoopFileName "`n"
Sort, FileList, %FileList%, R  <em>; The R option sorts in reverse order. See <a href="Sort.htm">Sort</a> for other options.</em>
Loop, Parse, %FileList%, `n
{
    if A_LoopField = ""  <em>; Ignore the blank item at the end of the list.</em>
        continue
    MsgBox, 4,, File number %A_Index% is %A_LoopField%.  Continue?
    if A_MsgBoxResult = "No"
        break
}</pre>
<p>&nbsp;</p>
<pre class="NoIndent"><em>; Beispiel #4: Retrieve file names sorted by modification date:</em>
FileList := ""
Loop, Files, %A_MyDocuments%\Photos\*.*, FD  <em>; Include files and directories.</em>
    FileList .= A_LoopFileTimeModified "`t" A_LoopFileName "`n"
Sort, FileList, %FileList%  <em>; Sort by date.</em>
Loop, Parse, %FileList%, `n
{
    if A_LoopField = "" <em>; Omit the last linefeed (blank item) at the end of the list.</em>
        continue
    FileItem := StrSplit(A_LoopField, A_Tab)  <em>; Split into two parts at the tab char.</em>
    MsgBox, 4,, % "The next file (modified at " FileItem[1] ") is:`n" FileItem[2] "`n`nContinue?"
    if A_MsgBoxResult = "No"
        break
}</pre>
<p>&nbsp;</p>
<pre class="NoIndent"><em>; Beispiel #5: Copy only the source files that are newer than their counterparts
; in the destination:</em>
CopyIfNewer:
<em>; Caller has set the variables CopySourcePattern and CopyDest for us.</em>
Loop, Files, %CopySourcePattern%
{
    copy_it := false
    if !FileExist(CopyDest "\" A_LoopFileName)  <em>; Always copy if target file doesn't yet exist.</em>
        copy_it := true
    else
    {
        FileGetTime, time, %CopyDest%\%A_LoopFileName%
        time := DateDiff(A_Now, A_LoopFileTimeModified, "Seconds")  <em>; Subtract the source file's time from the destination's.</em>
        if time &lt; 0  <em>; Source file is newer than destination file.</em>
            copy_it := true
    }
    if copy_it
    {
        FileCopy, %A_LoopFilePath%, %CopyDest%\%A_LoopFileName%, 1   <em>; Copy with overwrite=yes</em>
        if ErrorLevel
            MsgBox, Could not copy "%A_LoopFilePath%" to "%CopyDest%\%A_LoopFileName%".
    }
}
Return</pre>
<p>&nbsp;</p>
<pre class="NoIndent"><em>; Beispiel #6: Convert filenames passed in via command-line parameters to long names,
; complete path, and correct uppercase/lowercase characters as stored in the file system.</em>
Loop Args.MaxIndex()  <em>; For each parameter (or file dropped onto a script):</em>
{
    GivenPath := Args[A_Index]
    Loop Files, %GivenPath%, FD  <em>; Include files and directories.</em>
        LongPath := A_LoopFilePath
    MsgBox The case-corrected long path name of file`n%GivenPath%`nis:`n%LongPath%
}</pre>

</body>
</html>
