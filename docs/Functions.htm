<!DOCTYPE HTML>
<html>
<head>
<title>Funktionen</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="robots" content="noindex, nofollow">
<link href="static/theme.css" rel="stylesheet" type="text/css" />
<script src="static/jquery.js" type="text/javascript"></script>
<script src="static/tree.jquery.js" type="text/javascript"></script>
<script src="static/ga.js" type="text/javascript"></script>
<script src="static/content.js" type="text/javascript"></script>
</head>

<body>
<h1>Funktionen</h1>

<h2>Inhaltsverzeichnis</h2>
<ul>
  <li><a href="#intro">Einführung und einfache Beispiele</a></li>
  <li><a href="#param">Parameter</a></li>
  <li><a href="#optional">Optionale Parameter</a></li>
  <li><a href="#return">Rückgabewerte an den Aufrufer</a></li>
  <li><a href="#Variadic">Variadische Funktionen</a></li>
  <li><a href="#Locals">Lokale Variablen</a></li>
  <li><a href="#DynCall">Dynamisches Aufrufen einer Funktion</a></li>
  <li><a href="#ShortCircuit">Logische Kurzschlussauswertung</a></li>
  <li><a href="#gosub">Verwenden von Subroutinen innerhalb einer Funktion</a></li>
  <li><a href="#remarks">Return, Exit und allgemeine Bemerkungen</a></li>
  <li><a href="#include">Scripts mittels #Include auf die gleichen Funktionen zugreifen lassen</a></li>
  <li><a href="#lib">Libraries mit Funktionen: Standard- und Benutzer-Library</a></li>
  <li><a href="#BuiltIn">Integrierte Funktionen</a></li>
</ul>
<h2><a name="intro" id="intro"></a>Einführung und einfache Beispiele</h2>
<p><a name="define"></a>Eine Funktion ist prinzipiell das gleiche wie eine Subroutine (<a href="commands/Gosub.htm">GoSub</a>), außer dass sie Parameter (Eingabewerte) von ihrem Aufrufer entgegennehmen kann. Darüber hinaus kann eine Funktion optional einen Wert an den Aufrufer zurückgeben. Das folgende Beispiel zeigt, wie eine einfache Funktion zwei Zahlen entgegennimmt und deren Summe zurückgibt:</p>
<pre>Addieren(x, y)
{
    return x + y   <em>; "<a href="commands/Return.htm">Return</a>" erwartet einen <a href="Variables.htm#Expressions">Ausdruck</a>.</em>
}</pre>
<p>So etwas nennt man auch eine <em>Funktionsdefinition</em>, weil es eine Funktion mit dem Namen "Addieren" erstellt (Groß- und Kleinschreibung ist egal) und festlegt, dass jeder, der sie aufruft, genau zwei Parameter (x und y) bereitstellen muss. Um die Funktion aufzurufen, speichert man ihr Ergebnis mithilfe des <a href="commands/SetExpression.htm">Doppelpunkt-Gleich-Operators</a> (<strong><a href="commands/SetExpression.htm">:=</a></strong>) in eine Variable. Zum Beispiel:</p>
<pre>Var := Addieren(2, 3)  <em>; Speichert die Zahl 5 in Var.</em></pre>
<p>Man kann eine Funktion auch aufrufen, ohne ihren Rückgabewert speichern zu müssen:</p>
<pre>Addieren(2, 3)</pre>
<p>In diesem Fall aber wird der zurückgegebene Wert der Funktion verworfen; wenn die Funktion nur einen Rückgabewert erzeugen würde, wäre ihr Aufruf daher sinnlos.</p>
<p>Da ein Funktionsaufruf ein <a href="Variables.htm#Expressions">Ausdruck</a> ist, sollten Variablennamen in ihrer Parameterliste nicht von Prozentzeichen umschlossen sein. Dagegen sollten literale Strings in Anführungszeichen gesetzt werden. Zum Beispiel:</p>
<pre>if <a href="#InStr">InStr</a>(MeineVar, "Fuchs")
    MsgBox Die Variable MeineVar enthält das Wort Fuchs.</pre>
<p>Desweiteren kann man Funktionen innerhalb der Parameter eines Befehls aufrufen (außer in AusgabeVar-Parametern). Allerdings müssen Parameter, die keine <a href="Variables.htm#Expressions">Ausdrücke</a> unterstützen, den "%"-Präfix wie folgt verwenden:</p>
<pre>MsgBox <strong>%</strong> "Das Ergebnis ist: " <strong>.</strong> Addieren(3, 2)</pre>
<p>Das "%"-Präfix kann auch in Parametern verwendet werden, die bereits Ausdrücke unterstützen, aber es wird einfach ignoriert.</p>
<h2><a name="param" id="param"></a>Parameter</h2>
<p>Beim Definieren einer Funktion werden die Parameter neben dem Funktionsnamen in Klammern aufgelistet (Leerzeichen zwischen dem Namen und der öffnenden Klammer sind nicht erlaubt). Braucht die Funktion keine Parameter, können die Klammern leer gelassen werden; zum Beispiel: <code>ErmittleAktuellenZeitstempel()</code>.</p>
<p><a name="ByRef"></a><strong>ByRef-Parameter</strong>: Innerhalb der Funktion werden Parameter grundsätzlich wie <a href="#Locals">lokale Variablen</a> behandelt, sofern sie nicht wie folgt als <em>ByRef</em>-Parameter definiert werden:</p>
<pre>Tauschen(ByRef Links, ByRef Rechts)
{
    temp := Links
    Links := Rechts
    Rechts := temp
}</pre>
<p>Das Benutzen von <em>ByRef</em> bewirkt, dass die angegebene Variable mit dem Parameter verbunden wird. Das heißt, dass der Parameter und die Variable des Aufrufers auf den gleichen Inhalt im Arbeitsspeicher verweisen. Auf diese Weise kann die Tauschen-Funktion die Variablen des Aufrufers ändern, indem sie den Inhalt der <em>Links</em>-Variable in die <em>Rechts</em>-Variable verschiebt, und umgekehrt.</p>
<p>Würde man <em>ByRef</em> hingegen nicht verwenden, wären <em>Links</em> und <em>Rechts</em> nur Kopien der Variablen des Aufrufers - die Tauschen-Funktion hätte keine externe Auswirkung.</p>
<p>Da <a href="commands/Return.htm">Return</a> nur einen einzigen Wert an den Funktionsaufrufer zurückgeben kann, ist <em>ByRef</em> gut dafür geeignet, zusätzliche Ergebnisse zurückzugeben. Bringe den Aufrufer einfach dazu, eine Variable zu übergeben (üblicherweise leer), in der die Funktion einen Wert speichern kann.</p>
<p>Beim Übergeben langer Strings an eine Funktion ist <em>ByRef</em> leistungsfähiger und außerdem platzsparend, weil keine Kopie des Strings gemacht werden muss. Ebenso ist <em>ByRef</em>, wenn man einen langen String an den Aufrufer zurücksenden will, leistungsfähiger als <code>Return LangerString</code>.</p>
<p>Übergibt man etwas anderes als eine veränderbare Variable an einen ByRef-Parameter, verhält sich die Funktion so, als wäre das Schlüsselwort "ByRef" nicht vorhanden. Zum Beispiel würde <code>Tauschen(A_Index, i)</code> den Wert von <i>A_Index</i> in <i>i</i> speichern, aber den gespeicherten Wert in <i>Links</i> verwerfen, sobald die <i>Tauschen</i>-Funktion fertig ist.</p>
<p>Mit der <a href="#IsByRef">IsByRef()</a>-Funktion kann festgestellt werden, ob der Aufrufer eine Variable für einen bestimmten ByRef-Parameter bereitgestellt hat.</p>
<p>Bekannte Einschränkungen:</p>
<ul>
  <li>Objekteigenschaften (wie <code>foo.bar</code>), <a href="misc/Clipboard.htm">Clipboard</a> oder andere <a href="Variables.htm#BuiltIn">integrierte Variablen</a> können nicht per Verweis an eine Funktion übergeben werden. Stattdessen verhält sich die Funktion so, als ob <em>ByRef</em> weggelassen wurde.</li>
  <li><a name="recurse"></a>Theoretisch kann eine Funktion sich selbst rekursiv aufrufen. Wenn sie sich jedoch selbst ihre eigenen <a href="#Locals">lokalen Variablen</a> oder Nicht-ByRef-Parameter per <em>ByRef</em> übergibt, wird der <em>ByRef</em>-Parameter des neuen Ablegers auf seine eigene lokale Variable mit selben Namen verweisen, anstatt auf dem Namen des vorherigen Ablegers. Allerdings tritt dieses Problem nicht auf, wenn eine Funktion sich selbst eine <a href="#Global">globale Variable</a>, <a href="#static">statische Variable</a> oder einen <em>ByRef</em>-Parameter übergibt.</li>
  <li>Wenn ein Parameter bei einem Funktionsaufruf in eine Variable aufgelöst wird (z. B. <code>Var</code> oder <code>++Var</code> oder <code>Var *= 2</code>), können andere Parameter auf der linken oder rechten Seite diese Variable ändern, bevor sie an die Funktion übergeben wird. Zum Beispiel würde <code>Funktion(Var, Var++)</code> unerwartet eine 0 und 1 übergeben, wenn <em>Var</em> zu Beginn 0 ist, selbst wenn der erste Parameter der Funktion nicht als <em>ByRef</em> markiert ist. Da dieses Verhalten unlogisch ist, könnte es in einer zukünftigen Version geändert werden.</li>
</ul>
<h2 id="optional">Optionale Parameter</h2>
<p>Bei einer Funktionsdefinition können die Parameter als optional gekennzeichnet werden. Dies erfolgt durch Anfügen eines Zuweisungsoperators, gefolgt von einem Standardwert. Im folgenden Beispiel ist der Z-Parameter als optional gekennzeichnet:</p>
<pre>Addieren(X, Y, Z := 0) {
    return X + Y + Z
}</pre>
<p>Übergibt der Aufrufer <strong>drei</strong> Parameter an die obere Funktion, wird der Standardwert von Z ignoriert. Wenn der Aufrufer aber nur <strong>zwei</strong> Parameter übergibt, wird in Z automatisch der Wert 0 gespeichert.</p>
<p id="missing">Es ist nicht möglich, alleinstehende optionale Parameter in der Mitte der Parameterliste zu verwenden. Das heißt, dass alle Parameter, die auf der rechten Seite des ersten optionalen Parameters vorkommen, auch als optional gekennzeichnet werden müssen. Beim Aufrufen der Funktion können die optionale Parameter in der Mitte der Parameterliste weggelassen werden, wie unten gezeigt:</p>
<pre>Funktion(1,, 3)
Funktion(X, Y:=2, Z:=0) {  <em>; Beachte, dass Z in diesem Fall weiterhin optional sein muss.</em>
    MsgBox %X%, %Y%, %Z%
}</pre>
<p><a name="OptionalByRef"></a><a href="#ByRef">ByRef-Parameter</a> unterstützen auch Standardwerte; zum Beispiel: <code>Funktion(ByRef p1 = "")</code>. Jedes Mal, wenn der Aufrufer einen solchen Parameter weglässt, erstellt die Funktion eine lokale Variable, die den Standardwert enthält; das heißt, dass die Funktion sich so verhält, als würde das Schlüsselwort "ByRef" fehlen.</p>
<p>Als Standardwert eines Parameters sind folgende Werte zulässig: <code>True</code>, <code>False</code>, ein literaler Integer, eine literale Fließkommazahl oder ein literaler String wie "fox" oder "".</p>
<h2 id="return">Rückgabewerte an den Aufrufer</h2>
<p>Wie man bereits in der <a href="#intro">Einführung</a> lesen konnte, kann eine Funktion dazu gebracht werden, einen Wert per <a href="commands/Return.htm">Return</a> an ihren Aufrufer zurückzugeben.</p>
<pre>
Test := returnTest()
MsgBox % Test

returnTest() {
  return 123
}
</pre>
<p>Wenn noch mehr Ergebnisse von einer Funktion zurückgegeben werden sollen, kann man auch <a href="#ByRef">ByRef</a> verwenden:</p>
<pre>
returnByRef(A,B,C)
MsgBox % A "," B "," C

returnByRef(ByRef val1, ByRef val2, ByRef val3)
{
  val1 := "A"
  val2 := 100
  val3 := 1.1
  return
}
</pre>
<pre>
Test1 := returnArray1()
MsgBox % Test1[1] "," Test1[2]

Test2 := returnArray2()
MsgBox % Test2[1] "," Test2[2]

Test3 := returnObject()
MsgBox % Test3.id "," Test3.val

returnArray1() {
  Test := [123,"ABC"]
  return Test
}

returnArray2() {
  x := 456
  y := "EFG"
  return [x, y]
}

returnObject() {
  Test := {id: 789, val: "HIJ"}
  return Test
}
</pre>
<h2 id="Variadic">Variadische Funktionen</h2>
<p>Bei einer Funktionsdefinition kann ein Sternchen nach dem letzten Parameter angegeben werden, um die Funktion als variadisch zu kennzeichnen, so dass sie eine beliebige Anzahl an Parametern akzeptieren kann:</p>
<pre>Verbinden(sep, <b class="blue">params*</b>) {
    for index,param in params
        str .= param . sep
    return SubStr(str, 1, -StrLen(sep))
}
MsgBox % Verbinden("`n", "eins", "zwei", "drei")</pre>
<p>Ruft man eine variadische Funktion auf, sind überschüssige Parameter über ein Objekt zugreifbar, das im letzten Parameter der Funktion gespeichert ist. Der erste überschüssige Parameter ist <code>params[1]</code>, der Zweite ist <code>params[2]</code> und so weiter. Da es ein Standard-<a href="objects/Object.htm">Objekt</a> ist, kann mit <code>params.<a href="objects/Object.htm#Length">Length</a>()</code> die Anzahl der Parameter ermittelt werden.</p>
<p>Hinweise:</p>
<ul>
  <li>Der "variadische" Parameter kann nur am Ende der formalen Parameterliste verwendet werden.</li>
  <li><a href="misc/RegExCallout.htm">RegEx-Callouts</a> können nicht variadisch sein; der "variadische" Parameter wird zwar toleriert, aber leer gelassen.</li>
  <li><a href="commands/RegisterCallback.htm">Callbacks</a> übergeben überschüssige Parameter <a href="commands/RegisterCallback.htm#Indirect">per Adresse</a>, anstatt per Array.</li>
</ul>
<h3 id="VariadicCall">Variadische Funktionsaufrufe</h3>
<p>Während variadische Funktionen eine beliebige Parameteranzahl <i>akzeptieren</i> können, kann ein Array mit Parametern an <i>jede</i> Funktion durch Anwenden der gleichen Syntax beim Funktionsaufruf übergeben werden:</p>
<pre>Teilstrings := ["eins", "zwei", "drei"]
MsgBox % Verbinden("`n", <b class="blue">Teilstrings*</b>)</pre>
<p>Hinweise:</p>
<ul>
  <li>Die Nummerierung der Parameter beginnt innerhalb des Quell-Arrays bei 1.</li>
  <li>Optionale Parameter können im Array ganz weggelassen werden.</li>
  <li>Das Array mit Parametern kann benannte Elemente beim Aufrufen einer benutzerdefinierten Funktion enthalten; in allen anderen Fällen werden benannte Elemente nicht unterstützt.</li>
  <li>Die Zielfunktion kann auch variadisch sein - in diesem Fall werden benannte Elemente kopiert, selbst wenn sie keine entsprechenden formalen Parameter haben.</li>
  <li>Diese Syntax kann auch zum Aufrufen einer Methode oder zum Setzen bzw. Abrufen von Objekteigenschaften verwendet werden; zum Beispiel <code>Objekt.Eigenschaft[Params*]</code>.</li>
</ul>
<p>Bekannte Einschränkungen:</p>
<ul>
  <li>Nur der Parameter, der ganz rechts vorkommt, kann auf diese Weise erweitert werden. Zum Beispiel wird <code>Funktion(x, y*)</code> unterstützt, aber nicht <code>Funktion(x*, y)</code>.</li>
  <li>Es dürfen keine Leerraumzeichen zwischen dem Sternchen (<code>*</code>) und dem Endzeichen der Parameterliste vorkommen.</li>
</ul>
<h2 id="Locals">Lokale und globale Variablen</h2>
<h3>Lokale Variablen</h3>
<p>Alle Variablen, die innerhalb einer Funktion abgerufen oder erstellt werden, sind standardmäßig <em>lokal</em> (außer <a href="#SuperGlobal">superglobale</a> Variablen und integrierte Variablen wie <a href="misc/Clipboard.htm">Clipboard</a>, <a href="misc/ErrorLevel.htm">ErrorLevel</a> und <a href="Variables.htm#TimeIdle">A_TimeIdle</a>). Die Inhalte der lokalen Variablen sind nur für Zeilen innerhalb der Funktion sichtbar. Daher kann eine lokale Variable den gleichen Namen haben wie eine globale Variable, aber mit unterschiedlichem Inhalt. Alle lokalen Variablen sind zu Beginn leer, und das jedes Mal, wenn die Funktion aufgerufen wird.</p>
<h3 id="Global">Globale Variablen</h3>
<p>Um innerhalb einer Funktion auf eine vorhandene globale Variable zu verweisen (oder eine neue zu erstellen), deklariere die Variable als global, bevor man sie verwendet. Zum Beispiel:</p>
<pre>LogZuDatei(TextZuLog)
{
    <strong>global</strong> LogDateiname  <em>; Dieser globalen Variable wurde bereits ein Wert außerhalb dieser Funktion zugewiesen.</em>
    FileAppend, %TextZuLog%`n, %LogDateiname%
}</pre>
<p><a name="AssumeGlobal"></a><strong>Global-behandelnder Modus</strong>: Muss eine Funktion viele globale Variablen erstellen oder auf sie zugreifen, kann die Funktion so definiert werden, dass sie all ihre Variablen (außer ihre Parameter) global behandelt. Dazu muss in der ersten Zeile das Wort "global" stehen. Zum Beispiel:</p>
<pre>SetzeStandardwerte()
{
    <strong>global</strong>
    MeineGlobal := 33  <em>; Speichert 33 in eine globale Variable und erstellt sie, falls notwendig.</em>
    local x, y:=0, z  <em>; Lokale Variablen müssen in diesem Modus deklariert werden, weil sie sonst global behandelt werden.</em>
}</pre>
<p>Dieser global-behandelnde Modus kann auch von einer Funktion verwendet werden, um ein globales <a href="misc/Arrays.htm">Pseudo-Array</a> zu erstellen - wie bei einer Schleife, die Werte per <code>Array%A_Index%</code> zuweist.</p>
<p id="SuperGlobal"><strong>Superglobale Variablen</strong>: Geschieht eine globale Deklaration außerhalb einer Funktion, gilt sie standardmäßig für alle Funktionen. Dadurch wird verhindert, dass die Variablen jedes Mal in einer Funktion neu deklariert werden müssen. Funktionsparameter oder lokale Variablen mit gleichem Namen haben Vorrang vor der globalen Variable. Variablen, die mit dem Schlüsselwort <a href="Objects.htm#Custom_Classes">class</a> erzeugt wurden, sind auch superglobal.</p>
<h3 id="static">Statische Variablen</h3>
<p>Statische Variablen sind im Prinzip immer lokal. Der Unterschied ist aber, dass ihre Werte zwischen den Funktionsaufrufen erhalten bleiben. Zum Beispiel:</p>
<pre>LogZuDatei(TextZuLog)
{
    <strong>static</strong> Zeilenanzahl := 0
    Zeilenanzahl += 1  <em>; Behandelt einen Zähler lokal (der Wert bleibt zwischen den Funktionsaufrufen erhalten).</em>
    global LogDateiname
    FileAppend, %Zeilenanzahl%: %TextZuLog%`n, %LogDateiname%
}</pre>
<p><a name="InitStatic"></a>Eine statische Variable kann direkt bei ihrer Deklaration initialisiert werden - durch Anfügen von <code>:=</code>, gefolgt von einem beliebigen <a href="Variables.htm#Expressions">Ausdruck</a>. Zum Beispiel: <code>static X:=0, Y:="Fuchs"</code>. Jede statische Variable wird nur einmal initialisiert. Statische Variablen werden in der Reihenfolge initialisiert, wie sie in der Script-Datei angezeigt werden, aber bevor der automatische Ausführungsbereich des Scripts erfolgt.</p>
<p><a name="AssumeStatic"></a><strong>Statisch-behandelnder Modus</strong>: Eine Funktion kann so definiert werden, dass sie all ihre Variablen (außer ihre Parameter) statisch behandelt. Dazu muss in der ersten Zeile das Wort "static" stehen. Zum Beispiel:</p>
<pre>ErmittleVomStatischenArray(Elementnummer)
{
    <strong>static</strong>
    static ErsterAufruf := true  <em>; Die Initialisierung einer statischen Deklaration wird nur einmal ausgeführt (beim Start).</em>
    if ErsterAufruf  <em>; Erstellt ein statisches Array beim ersten Aufruf, aber nicht mehr danach.</em>
    {
        ErsterAufruf := false
        Loop 10
            StatischesArray%A_Index% := "Wert #" . A_Index
    }
    return StatischesArray%Elementnummer%
}</pre>
<p>Im statisch-behandelnden Modus muss jede Variable, die nicht statisch sein soll, als lokal oder global deklariert werden.</p>
<h3>Mehr über lokale und globale Variablen</h3>
<p>Es ist möglich, mehrere Variablen auf der gleichen Zeile zu deklarieren, wenn sie wie folgt durch Kommas getrennt werden:</p>
<pre>global LogDateiname, MaxVersuche := 5
static GesamtVersuche := 0, VorherErgebnis</pre>
<p><a name="DeclareInit"></a>Eine lokale oder globale Variable kann direkt bei ihrer Deklaration initialisiert werden - durch Anfügen von <code>:=</code>, gefolgt von einem beliebigen <a href="Variables.htm#Expressions">Ausdruck</a>. Im Gegensatz zu <a href="#InitStatic">statischen Initialisierungen</a> werden die Initialisierungen von lokalen oder globalen Variablen bei jedem Funktionsaufruf ausgeführt, sofern sie von der Ablaufsteuerung erreicht werden. Das heißt, dass eine Zeile wie <code>local x := 0</code> den gleichen Effekt hat wie die zwei folgenden Zeilen: <code>local x</code>, gefolgt von <code>x := 0</code>.</p>
<p>Da die Wörter <em>local</em>, <em>global</em> und <em>static</em> unmittelbar beim Starten des Scripts verarbeitet werden, kann eine Variable nicht bedingt per <a href="commands/IfExpression.htm">IF-Anweisung</a> deklariert werden. Das heißt, dass eine Deklaration innerhalb eines IF- oder ELSE-<a href="commands/Block.htm">Blocks</a> bedingungslos für alle Zeilen zwischen der Deklaration und der schließenden Funktionsklammer wirksam wird. Beachte zudem, dass es zurzeit nicht möglich ist, eine dynamische Variable wie <code>global Array%i%</code> zu deklarieren.</p>

<h2 id="DynCall">Dynamisches Aufrufen einer Funktion</h2>
<p>Eine Funktion (auch eine <a href="#BuiltIn">integrierte Funktion</a>) kann mithilfe von Prozentzeichen dynamisch aufgerufen werden. Zum Beispiel würde <code>%Var%(x, "Fuchs")</code> die Funktion aufrufen, deren Name in <em>Var</em> enthalten ist. Ebenso würde <code>Funktion%A_Index%()</code> Funktion1(), Funktion2() und so weiter aufrufen, abhängig vom aktuellen Wert in A_Index.</p>
<p><em>Var</em> in <code>%Var%()</code> kann einen Funktionsnamen, <a href="objects/Func.htm">Funktionsverweis</a> oder ein <a href="Objects.htm#Objects_as_Functions">Funktion-nachahmendes Objekt</a> enthalten. Falls die Funktion nicht existiert, wird stattdessen die __Call-Meta-Funktion des <a href="Objects.htm#Default_Base_Object">Standard-base-Objekts</a> aufgerufen.</p>
<p>Kann die Funktion aufgrund einer der unten genannten Gründe nicht aufgerufen werden, wird eine <a href="Catch.htm#RuntimeErrors">Ausnahme</a> ausgelöst:</p>
<ul>
  <li>Aufrufen einer nicht-existierenden Funktion, das mithilfe von <code>If <a href="#IsFunc">IsFunc</a>(VariableMitFunktionsname)</code> verhindert werden kann. Die <a href="#define">Definition</a> der aufgerufenen Funktion (außer <a href="#BuiltIn">integrierte Funktionen</a>) muss explizit im Script vorkommen (zum Beispiel über <a href="commands/_Include.htm">#Include</a> oder einem nicht-dynamischen Aufruf einer <a href="#lib">Library-Funktion</a>).</li>
  <li>Übergeben von zu wenigen Parametern, das verhindert werden kann, wenn der Rückgabewert von <a href="#IsFunc">IsFunc()</a> überprüft wird (das ist die Anzahl der Pflichtparameter plus 1). Hinweis: Das Übergeben von zu vielen Parametern wird toleriert; jeder zusätzliche Parameter wird vollständig ausgewertet (einschließlich aller Funktionsaufrufe) und dann verworfen.</li>
</ul>
<p>Beachte, dass ein dynamischer Aufruf einer Funktion etwas langsamer ist als ein normaler Aufruf, weil normale Aufrufe aufgelöst (nachgeschlagen) werden, bevor das Script seine Ausführung beginnt.</p>
<h2 id="ShortCircuit">Logische Kurzschlussauswertung</h2>
<p>Sobald <em>AND, OR</em> und der <a href="Variables.htm#ternary">ternäre Operator</a> innerhalb eines <a href="Variables.htm#Expressions">Ausdrucks</a> verwendet werden, schließen sie sich kurz, um die Performance zu erhöhen (egal ob Funktionsaufrufe vorhanden sind oder nicht). Beim Kurzschließen werden nur Bereiche des Ausdrucks ausgewertet, die Einfluss auf das Endergebnis haben. Im folgenden Beispiel wird gezeigt, wie genau das funktioniert:</p>
<pre>if (FarbName &lt;&gt; "" AND not FindeFarbe(FarbName))
    MsgBox %FarbName% konnte nicht gefunden werden.</pre>
<p>Wenn die <em>FarbName</em>-Variable leer sein sollte, wird die FindeFarbe()-Funktion niemals aufgerufen, weil die linke Seite von <em>AND</em> als <em>falsch</em> gewertet wird, wodurch die rechte Seite nicht mehr in der Lage wäre, das Endergebnis auf <em>wahr</em> zu bringen.</p>
<p>Dieses Verhalten führt dazu, dass Nebeneffekte von einer Funktion (wie das Ändern des Inhalts einer globalen Variable) nie auftreten werden, wenn diese Funktion auf der rechten Seite von <em>AND</em> oder <em>OR</em> aufgerufen wird.</p>
<p>Beachte außerdem, dass die Kurzschlussauswertung verschachtelte <em>AND</em>s und <em>OR</em>s stufenweise durchgeht. Im Ausdruck des folgenden Beispiels würde nur der Vergleich ganz links erfolgen, wann immer <em>FarbName</em> leer ist, weil die linke Seite dann ausreichen würde, um das Endergebnis mit Sicherheit zu bestimmen:</p>
<pre>if (FarbName = "" <u>OR</u> FindeFarbe(FarbName, Region1) <u>OR</u> FindeFarbe(FarbName, Region2))
    break   <em>; Nichts zu durchsuchen oder Übereinstimmung gefunden.</em></pre>
<p>Wie die Beispiele oben zeigen, sollten lange (zeitaufwendige) Funktionen generell auf der rechten Seite von <em>AND</em> oder <em>OR</em> aufgerufen werden, um die Performance zu erhöhen. Diese Technik kann auch dazu genutzt werden, das Aufrufen einer Funktion zu verhindern, wenn ein ungeeigneter Wert (z. B. ein leerer String) an einen ihrer Parameter übergeben wird.</p>
<p>Außerdem erfolgt beim <a href="Variables.htm#ternary">ternären Bedingungsoperator (?:)</a> eine Kurzschließung durch Ignorieren der verlierenden Abzweigung.</p>
<h2 id="gosub">Verwenden von Subroutinen innerhalb einer Funktion</h2>
<p>Eine Funktion kann keine <a href="#define">Definitionen</a> von anderen Funktionen enthalten. Subroutinen sind aber möglich. Sie können, wie jede andere Subroutine auch, per <a href="commands/Gosub.htm">GoSub</a> gestartet und per <a href="commands/Return.htm">Return</a> beendet werden (in diesem Fall gilt das Return nicht für die Funktion, sondern für das GoSub).</p>
<p><a name="GosubPublic"></a>Verwendet eine Funktion das <a href="commands/Gosub.htm">GoSub</a>, um zu einer öffentlichen Subroutine zu springen (die sich außerhalb der Funktionsklammern befindet), sind alle Variablen außerhalb global und die funktions-eigenen <a href="#Locals">lokalen Variablen</a> nicht abrufbar, bis die Subroutine ihr Return erreicht hat. Allerdings wird A_ThisFunc weiterhin den Namen der Funktion enthalten.</p>
<p>Das <a href="commands/Goto.htm">Goto</a> kann nicht verwendet werden, um vom Inneren der Funktion nach außen zu springen. Allerdings kann eine Funktion per <a href="commands/Gosub.htm">GoSub</a> zu einer externen/öffentlichen Subroutine springen und von dort aus per Goto weiterspringen.</p>
<p>In der Regel sollte man auf <a href="commands/Goto.htm">Goto</a> verzichten. Dieser Befehl kann aber in einer Funktion nützlich sein, um innerhalb dieser Funktion auf eine andere Position zu springen. Dies kann helfen, komplexe Funktionen zu vereinfachen, die mehrere Rückgabepunkte haben, bei denen zuvor einige Säuberungsaktionen durchgeführt werden müssen.</p>
<p>Eine Funktion kann extern-aufrufende Subroutinen wie <a href="commands/SetTimer.htm">Timer</a>, <a href="commands/Gui.htm#label">g-Label</a> und <a href="commands/Menu.htm">Menüpunkte</a> enthalten. Dies erfolgt normalerweise, um sie für <a href="commands/_Include.htm">#Include</a> in eine separate Datei einzubetten, so dass sie den <a href="Scripts.htm#auto">automatischen Ausführungsbereich</a> des Scripts nicht stören können. Allerdings gelten folgende Einschränkungen:</p>
<ul>
  <li>Solche Subroutinen sollten nur <a href="#static">statische</a> und <a href="#Global">globale</a> Variablen verwenden (keine <a href="#Locals">lokalen</a>), wenn ihre Funktionen normal aufgerufen werden, weil ein Subroutinen-<a href="misc/Threads.htm">Thread</a>, der den Thread eines Funktionsaufrufs unterbricht (oder umgekehrt), in der Lage wäre, die Werte von lokalen Variablen zu ändern, wie sie vom unterbrochenen Thread gesehen werden. Jedes Mal, wenn eine Funktion zu ihrem Aufrufer zurückkehrt, werden all ihre lokale Variablen leer gemacht, um deren Speicher freizugeben.</li>
  <li>Solche Subroutinen sollten nur <a href="#Global">globale Variablen</a> (keine <a href="#static">statischen Variablen</a>) als <a href="commands/Gui.htm#var">GUI-Steuerelement-Variablen</a> verwenden.</li>
  <li>Wenn eine Funktion von einem Subroutinen-<a href="misc/Threads.htm">Thread</a> betreten wird, werden alle Verweise auf <a href="misc/Arrays.htm">dynamische Variablen</a>, die von diesem Thread erstellt wurden, als <a href="#Global">globale Variablen</a> behandelt (einschließlich array-erstellende Befehle). Außerdem können <a href="misc/Labels.htm">lokale Label</a> nicht dynamisch verwiesen werden.</li>
</ul>
<h2 id="remarks">Return, Exit und allgemeine Bemerkungen</h2>
<p>Erreicht der Ausführungsablauf innerhalb einer Funktion die schließende Funktionsklammer, ohne auf ein <a href="commands/Return.htm">Return</a> gestoßen zu sein, endet die Funktion und gibt ihren Aufrufer einen leeren String zurück. Ein leerer Wert wird auch zurückgegeben, wenn der Parameter von <a href="commands/Return.htm">Return</a> explizit fehlt.</p>
<p>Wenn eine Funktion den <a href="misc/Threads.htm">aktuellen Thread</a> mit dem <a href="commands/Exit.htm">Exit</a>-Befehl terminiert, erhält ihr Aufrufer überhaupt keinen Rückgabewert. Zum Beispiel: Die Anweisung <code>Var := Addieren(2, 3)</code> würde <code>Var</code> unverändert belassen, wenn <code>Add()</code> per Exit beendet wird. Das gleiche passiert, wenn die Funktion einen Laufzeitfehler verursacht, wie das <a href="commands/Run.htm">Ausführen</a> einer nicht-existierenden Datei (nur wenn <a href="commands/Run.htm#UseErrorLevel">UseErrorLevel</a> nicht aktiv ist).</p>
<p>Eine Funktion kann den Wert von <a href="misc/ErrorLevel.htm">ErrorLevel</a> ändern, um einen zusätzlichen Wert zurückzugeben, der sich leicht merken lässt.</p>
<p>Um eine Funktion mit einem oder mehreren leeren Strings aufzurufen, verwende zwei Anführungszeichen wie folgt: <code>FindeFarbe(FarbName, "")</code>.</p>
<p>Da das Aufrufen einer Funktion keinen neuen <a href="misc/Threads.htm">Thread</a> startet, werden von der Funktion geänderten Einstellungen wie <a href="commands/SendMode.htm">SendMode</a> oder <a href="commands/SetTitleMatchMode.htm">SetTitleMatchMode</a> auch für den Aufrufer wirksam.</p>
<p>Der Aufrufer einer Funktion kann nicht-existierende Variablen oder <a href="misc/Arrays.htm">Array</a>-Elemente an ihr übergeben, was nützlich für Funktionen ist, die den entsprechenden Parameter als <a href="#ByRef">ByRef</a> erwarten. Ruft man beispielsweise <code>ErmittleNächsteZeile(LeeresArray%i%)</code> auf, wird die Variable <code>LeeresArray%i%</code> automatisch als <a href="#Locals">lokale</a> oder globale Variable erstellt (abhängig davon, ob der Aufrufer sich in einer Funktion befindet und ob der <a href="#AssumeGlobal">global-behandelnder Modus</a> wirksam ist).</p>
<p>Wenn <a href="commands/ListVars.htm">ListVars</a> in einer Funktion verwendet wird, werden ihre <a href="#Locals">lokalen Variablen</a> und deren Inhalte angezeigt. Dies kann dabei helfen, ein Script zu debuggen.</p>
<h2>Stil und Namenskonventionen</h2>
<p>Man könnte komplexe Funktionen als besser lesbar und verwaltbar empfinden, wenn deren Variablen eindeutige Präfixe angefügt werden. Durch Hinzufügen von beispielsweise "p" oder "p_" am Anfang jeden Parameters ist seine besondere Art besser erkennbar, besonders wenn eine Funktion sehr viele <a href="#Locals">lokale Variablen</a> hat. Ebenso kann das Präfix "r" oder "r_" für <a href="#ByRef">ByRef-Parameter</a> und "s" oder "s_" für <a href="#static">statische Variablen</a> verwendet werden.</p>
<p>Bei Bedarf kann der "<a href="commands/Block.htm#otb">One True Brace Style</a>" verwendet werden, um Funktionen zu definieren. Zum Beispiel:</p>
<pre>Addieren(x, y) <strong>{</strong>
    return x + y
<strong>}</strong></pre>
<h2 id="include">Scripts mittels #Include auf die gleichen Funktionen zugreifen lassen</h2>
<p>Die <a href="commands/_Include.htm">#Include</a>-Direktive kann verwendet werden (<em>auch am Anfang des Scripts</em>), um Funktionen aus einer externen Datei zu laden.</p>
<p>Erklärung: Erreicht der Ausführungsablauf des Scripts eine Funktionsdefinition, wird er sie sofort überspringen und seine Ausführung bei der Zeile nach der schließenden Klammer fortsetzen. Daraus folgt, dass die Ausführung nie in eine Funktion geraten kann, oder dass das Vorhandensein von einer oder mehreren Funktionen am Anfang des Scripts den <a href="Scripts.htm#auto">automatischen Ausführungsbereich</a> beeinflussen könnten.</p>
<h2><a name="lib" id="lib"></a>Libraries mit Funktionen: Standard- und Benutzer-Library</h2>
<p>Ein Script kann eine Funktion aus einer externen Datei aufrufen, ohne dabei <a href="commands/_Include.htm">#Include</a> verwenden zu müssen. Damit dies funktioniert, muss eine Datei, die den gleichen Namen hat wie die Funktion, in einem der folgenden Library-Verzeichnissen vorkommen:</p>
<pre><a href="Variables.htm#ScriptDir">%A_ScriptDir%</a>\Lib\  <em>; Lokale Library.</em>
<a href="Variables.htm#MyDocuments">%A_MyDocuments%</a>\AutoHotkey\Lib\  <em>; Benutzer-Library.</em>
Pfad-zur-gerade-laufenden-AutoHotkey.exe\Lib\  <em>; Standard-Library.</em></pre>
<p>Ruft ein Script beispielsweise die nicht-existierende Funktion <code>MeineFunktion()</code> auf, sucht das Programm nach einer Datei namens "MeineFunktion.ahk" in der Benutzer-Library. Wenn sie dort nicht gefunden werden kann, wird die Standard-Library durchsucht. Ergibt die Suche weiterhin keine Treffer und enthält der Funktionsname einen Unterstrich (z. B. <code>MeinPräfix_MeineFunktion</code>), sucht das Programm in beiden Libraries nach einer Datei namens <code>MeinPräfix.ahk</code> und lädt sie, falls sie existiert. Auf diese Weise kann <code>MeinPräfix.ahk</code> sowohl die Funktion <code>MeinPräfix_MeineFunktion</code> als auch andere verwandte Funktionen enthalten, deren Namen mit <code>MeinPräfix_</code> beginnen.</p>
<p>Die lokale Library wird durchsucht, bevor die Benutzer- und Standard-Library durchsucht wird.</p>
<p>In der Regel enthält eine Library-Datei nur eine einzelne Funktion, die den gleichen Namen hat wie die Datei. Sie kann aber auch private Funktionen und Subroutinen enthalten, die nur von ihr aufgerufen werden. Die Namen solcher Funktionen sollten jedoch gut durchdacht sein, da sie weiterhin im globalen Namensraum zur Verfügung stehen; das heißt, dass sie von überall im Script aufgerufen werden können.</p>
<p>Verwendet eine Library-Datei <a href="commands/_Include.htm">#Include</a>, gilt als Arbeitsverzeichnis für #Include das Verzeichnis der Library-Datei. Dies ermöglicht das Erzeugen einer Weiterleitung zu einer größeren Library-Datei, die diese Funktion und andere dazugehörige Funktionen enthält.</p>
<p>Der <a href="Scripts.htm#ahk2exe">Script-Compiler (ahk2exe)</a> unterstützt auch Library-Funktionen. Allerdings ist eine Kopie von AutoHotkey.exe im Verzeichnis oberhalb des Compiler-Verzeichnisses notwendig (was normalerweise der Fall ist). Wenn AutoHotkey.exe dort nicht vorhanden, wird der Compiler zwar weiterhin funktionieren, aber die Library-Funktionen werden nicht mehr automatisch eingefügt.</p>
<p>Funktionen, die auf diese Weise eingefügt werden, haben die gleiche Performance wie andere Funktionen, weil sie geladen werden, bevor das Script seine Ausführung beginnt.</p>
<h2 id="BuiltIn">Integrierte Funktionen</h2>
<p>Jeder optionale Parameter, der am Ende der Parameterliste einer integrierten Funktion vorkommt, kann komplett weggelassen werden. Zum Beispiel könnte man <code>WinExist("Unbenannt - Editor")</code> angeben, weil die Funktion ihre anderen drei Parameter als leere Werte ansieht.</p>
<p>Eine integrierte Funktion wird überschrieben, wenn das Script seine eigene Funktion mit dem gleichen Namen definieren würde. Zum Beispiel könnte man anstelle der normalen WinExist()-Funktion eine selbstdefinierte Funktion verwenden. Allerdings kann danach die originale Funktion nicht mehr aufgerufen werden.</p>
<p>Externe Funktionen, die sich in DLL-Dateien befinden, können per <a href="commands/DllCall.htm">DllCall()</a> aufgerufen werden.</p>
<h3>Häufig verwendete Funktionen</h3>
<p><strong><a name="FileExist"></a>FileExist(Dateimuster)</strong>: Gibt einen leeren String zurück, wenn <em>Dateimuster</em> nicht existiert (<em>Dateimuster</em> befindet sich im <a href="Variables.htm#WorkingDir">A_WorkingDir</a>-Verzeichnis, solange kein absoluter Pfad angegeben ist). Ansonsten wird ein <a href="commands/FileGetAttrib.htm#attrib">String mit Attributen</a> (eine Teilmenge von "RASHNDOCT") von der ersten gefundenen Datei oder des ersten gefundenen Ordners zurückgegeben. Hat die Datei keine Attribute (was sehr selten ist), wird "X" zurückgegeben. <em>Dateimuster</em> kann der exakte Name einer Datei oder eines Ordners sein, oder Platzhalter (* oder ?) enthalten. Da ein leerer String als "falsch" angesehen wird, kann der Rückgabewert der Funktion immer als logischer Scheinwert verwendet werden. Zum Beispiel würde die Anweisung <code>if FileExist("C:\Meine Datei.txt")</code> als wahr angesehen werden, wenn die Datei vorhanden ist. Ebenso würde die Anweisung <code>if InStr(FileExist("C:\Meine Ordner"), "D")</code> nur als wahr angesehen werden, wenn die Datei existiert <em>und</em> ein Verzeichnis ist. Dazugehöriger Befehl: <a href="commands/FileGetAttrib.htm">FileGetAttrib</a>.</p>
<p id="DirExist"><strong>DirExist(Dateimuster)</strong>: Das gleiche wie <a href="#FileExist">FileExist()</a>, außer dass ein leerer String zurückgegeben wird, wenn <em>Dateimuster</em> kein Verzeichnis ist.</p>
<p><strong><a name="GetKeyState"></a>GetKeyState(<a href="KeyList.htm">Tastenname</a> [, "P"</strong> oder <strong>"T"])</strong>: Siehe <a href="commands/GetKeyState.htm">GetKeyState</a>.</p>
<p><strong><a name="InStr"></a>InStr(Heuhaufen, Nadel [, Zeichengenauigkeit = false, Startposition = 1, Vorkommen = 1])</strong>: Gibt die Position des Strings <em>Nadel</em> zurück, der im String <em>Heuhaufen</em> vorkommt. Position 1 ist das erste Zeichen; das liegt daran, dass 0 das Synonym für "falsch" ist, was sich gut als "nicht gefunden" eignet. Ist der <em>Zeichengenauigkeit</em>-Parameter nicht vorhanden oder "falsch", unterscheidet die Suche nicht zwischen Groß- und Kleinschreibung (die Unterscheidung hängt von <a href="commands/StringCaseSense.htm">StringCaseSense</a> ab); ansonsten muss die Groß- und Kleinschreibung exakt übereinstimmen. Ist <em>Startposition</em> nicht vorhanden, gilt standardmäßig 1 (der Anfang von <em>Heuhaufen</em>). Ansonsten kann man eine 2 angeben, um die Suche im <em>Heuhaufen</em> beim zweiten Zeichen zu beginnen, eine 3, um beim dritten Zeichen zu beginnen, und so weiter. Überschreitet <em>Startposition</em> die Länge von <em>Heuhaufen</em>, wird eine 0 zurückgegeben. Wenn <em>Startposition</em> negativ ist, erfolgt die Suche in umgekehrter Reihenfolge (von rechts nach links), beginnend an dieser Position von rechts gezählt. Ungeachtet des Wertes in <em>Startposition</em> bezieht sich der Rückgabewert immer auf das erste Zeichen von <em>Heuhaufen</em>. Zum Beispiel wäre die Position von "abc" in "123abc789" immer 4. Schreibe eine 2 in <i>Vorkommen</i>, um die Position der zweiten Übereinstimmung zurückzugeben, eine 3 für die dritte Übereinstimmung und so weiter. Siehe auch: <a href="commands/RegExMatch.htm">RegExMatch()</a>.</p>
<p><strong>RegExMatch(Heuhaufen, NadelRegEx [, AusgabeVar = "", Startposition = 1])</strong>: Siehe <a href="commands/RegExMatch.htm">RegExMatch()</a>.</p>
<p><strong>RegExReplace(Heuhaufen, NadelRegEx [, Ersatz = "", AusgabeVarAnzahl = "", Limit = -1, Startposition = 1])</strong>: Siehe <a href="commands/RegExReplace.htm">RegExReplace()</a>.</p>
<p><strong><a name="SubStr"></a>SubStr(String, Startposition [, Länge])</strong>: Kopiert einen Teilstring vom <em>String</em>, beginnend bei <em>Startposition</em> von links nach rechts, bis die angegebene <em>Länge</em> erreicht wurde (falls <em>Länge</em> nicht vorhanden ist, gilt standardmäßig "alle Zeichen"). Für <em>Startposition</em> kann eine 1 angegeben werden, um beim ersten Zeichen zu beginnen, eine 2, um beim zweiten Zeichen zu beginnen, und so weiter (überschreitet <em>Startposition</em> die Länge von <em>String</em>, wird ein leerer String zurückgegeben). Ist <em>Startposition</em> negativ, wird es als Offset vom Ende des Strings angesehen. Zum Beispiel würde -1 das letzte Zeichen und -2 die letzten zwei Zeichen extrahieren (überschreitet <em>Startposition</em> aber das linke Ende des Strings, beginnt das Extrahieren beim ersten Zeichen). <em>Länge</em> ist die maximale Anzahl an Zeichen, die extrahiert werden sollen (es werden weniger Zeichen abgerufen, falls der verbleibende Teil des Strings zu kurz ist). Verwende eine negative <em>Länge</em>, um die Anzahl an Zeichen zu bestimmen, die vom Ende des zurückgegebenen Strings weggelassen werden sollen (es wird ein leerer String zurückgegeben, wenn alle oder zu viele Zeichen weggelassen worden sind). Siehe auch: <a href="commands/RegExMatch.htm">RegExMatch()</a>.</p>
<p><strong><a name="StrLen"></a>StrLen(String)</strong>: Gibt die Länge von <em>String</em> zurück. Ist <em>String</em> eine Variable, der <a href="misc/Clipboard.htm#ClipboardAll">ClipboardAll</a> zugewiesen wurde, wird ihre Gesamtgröße in Bytes, geteilt durch 2, zurückgegeben.</p>
<p><strong><a name="StrSplit"></a>StrSplit(String [, Trennzeichen, ZeichenAuslassen])</strong>: Teilt einen String in mehrere Teilstrings auf, basierend auf die angegebenen Trennzeichen. Siehe <a href="commands/StrSplit.htm">StrSplit()</a> für Details.</p>
<p><strong><a name="WinActive"></a>WinActive([Fenstertitel, Fenstertext, Titelausnahme, Textausnahme])</strong>: Gibt die Eindeutige ID (HWND) des aktiven Fensters zurück, wenn es die  angegebenen Kriterien erfüllt. Siehe <a href="commands/WinActive.htm">WinActive()</a> für Details.</p>
<p><strong><a name="WinExist"></a>WinExist([Fenstertitel, Fenstertext, Titelausnahme, Textausnahme])</strong>: Gibt die <a href="commands/WinGet.htm">eindeutige ID (HWND)</a> des ersten übereinstimmenden Fensters zurück. Siehe <a href="commands/WinExist.htm">WinExist()</a> für Details.</p>
<h3>Verschiedene Funktionen</h3>
<p id="Ord"><strong>Ord(String)</strong>: Gibt den Ordinalwert des ersten Unicode-Zeichens in <em>String</em> zurück. Das ist typischerweise eine Zahl zwischen 1 und 65535 (0xFFFF), oder auch eine Zahl zwischen 0x10000 und 0x10FFFF, wenn <em>String</em> mit einem Ergänzungszeichen beginnt (kodiert als UTF-16-Ersatzzeichenpaar). Ist <em>String</em> leer, wird 0 zurückgegeben.</p>
<p><strong><a name="Chr"></a>Chr(Zahl)</strong>: Gibt das Zeichen zurück, das zum angegebenen Unicode-Zeichencode (<em>Zahl</em>) gehört. Liegt <em>Zahl</em> außerhalb des gültigen Bereichs der Zeichencodes, wird ein leerer String zurückgegeben. Häufig verwendete Zeichencodes sind 9 (Tabulator), 10 (LF), 13 (CR), 32 (Leerzeichen), 48-57 (die Zahlen von 0 bis 9), 65-90 (Großbuchstaben von A bis Z) und 97-122 (Kleinbuchstaben von a bis z). Zahlen im Bereich von 0x10000 bis 0x10FFFF erzeugen selten verwendete Ergänzungszeichen (kodiert als UTF-16-Ersatzzeichenpaar). Wenn <em>Zahl</em> eine Null ist, wird ein String mit einer binärischen Null (Länge 1) zurückgegeben.</p>
<p><strong>DllCall()</strong>: Ruft eine Funktion innerhalb einer DLL-Datei auf, wie z. B. eine API-Funktion von Windows. Siehe <a href="commands/DllCall.htm">DllCall()</a> für Details.</p>
<p><strong>FileOpen()</strong>: Ermöglicht eine objektorientierte Dateibearbeitung. Siehe <a href="commands/FileOpen.htm">FileOpen()</a> für Details.</p>
<p><strong><a name="Func"></a>Func(Funktionsname)</strong>: Falls <em>Funktionsname</em> im Script explizit nicht vorhanden ist (z. B. durch <a href="commands/_Include.htm">#Include</a> oder einen nicht-dynamischen Aufruf einer <a href="#lib">Library-Funktion</a>), wird Func() eine 0 zurückgeben. Ansonsten wird der <a href="Objects.htm#Function_References">Verweis auf die Funktion</a> zurückgegeben. Das kann man verwenden, um die Funktion aufzurufen oder <a href="objects/Func.htm">Informationen</a> abzurufen, wie beispielsweise die minimale und maximale Anzahl an Parametern.</p>
<p><strong><a name="GetKeyName"></a>GetKeyName(Taste), GetKeyVK(Taste), GetKeySC(Taste)</strong>: Ermittelt den Namen / Text, virtuellen Tastencode oder Scancode einer Taste. <em>Taste</em> kann ein VK oder SC-Code, wie z. B. "vkA2" oder "sc01D", eine Kombination von beiden oder ein Tastenname sein. Zum Beispiel wird sowohl <code>GetKeyName("vk1B")</code> als auch <code>GetKeyName("Esc")</code> "Escape" zurückgeben, während <code>GetKeyVK("Esc")</code> eine 27 zurückgibt.</p>
<p><strong><a name="IsByRef"></a>IsByRef(Var)</strong>: Gibt eine 1 zurück, falls <em>Var</em> ein ByRef-Parameter ist und der Aufrufer eine Variable übergibt; oder 0, falls <em>Var</em> ein anderer Variablentyp ist.</p>
<p><strong><a name="IsFunc"></a>IsFunc(Funktionsname)</strong>: Falls <em>Funktionsname</em> explizit im Script nicht vorhanden ist (z. B. durch <a href="commands/_Include.htm">#Include</a> oder einen nicht-dynamischen Aufruf einer <a href="#lib">Library-Funktion</a>), wird IsFunc() eine 0 zurückgeben. Ansonsten gibt sie die minimale Anzahl an Parametern zurück, addiert mit 1 (also 1 für eine Funktion ohne Parameter, 2 für eine Funktion mit einem Parameter und so weiter). Zum Beispiel würden die Anweisungen <code>if IsFunc("MeineFunktion")</code> und <code>if IsFunc(VariableMitFunktionsnamen)</code> als wahr angesehen werden, wenn die Funktion vorhanden ist. <i>Funktionsname</i> kann anstelle eines Namens auch ein Funktionsverweis sein. Siehe auch: <a href="#DynCall">Dynamischer Funktionsaufruf</a>, <a href="Variables.htm#ThisFunc">A_ThisFunc</a></p>
<p><strong><a name="IsLabel"></a>IsLabel(LabelName)</strong>: Gibt eine Zahl ungleich 0 zurück, wenn <em>Labelname</em> als <a href="commands/Gosub.htm">Subroutine</a>, <a href="Hotkeys.htm">Hotkey</a> oder <a href="Hotstrings.htm">Hotstring</a> im Script vorkommt (<em>Labelname</em> muss ohne den Doppelpunkten angegeben werden). Zum Beispiel würde die Anweisung <code>if IsLabel(VariableMitLabelnamen)</code> als wahr angesehen werden, wenn das Label vorhanden ist. Das ist nützlich, um Laufzeitfehler zu unterdrücken, wenn man ein dynamisches Label in Befehlen wie <a href="commands/Gosub.htm">Gosub</a>, <a href="commands/Hotkey.htm">Hotkey</a>, <a href="commands/Menu.htm">Menu</a> und <a href="commands/Gui.htm">Gui</a> angibt. Siehe auch: <a href="misc/Labels.htm">Label</a>.</p>
<p><strong><a name="IsObject"></a>IsObject()</strong>: Erkennt, ob ein Wert ein Objekt ist. Siehe auch: <a href="Objects.htm">Objekte</a>.</p>
<p><strong>ListView- und TreeView-Funktionen</strong>: Siehe <a href="commands/ListView.htm">ListView</a> und <a href="commands/TreeView.htm">TreeView</a> für Details.</p>
<p><strong><a name="NumGet"></a>NumGet(VarOderAdresse [, Offset = 0][, Typ = "UPtr"])</strong>: Siehe <a href="commands/NumGet.htm">NumGet</a>.</p>
<p><strong><a name="NumPut"></a>NumPut(Nummer, VarOderAdresse [, Offset = 0][, Typ = "UPtr"])</strong>: Siehe <a href="commands/NumPut.htm">NumPut</a>.</p>
<p><strong>OnMessage(Nachrichtennummer [, "Funktionsname"])</strong>: Überwacht eine Nachricht/ein Ereignis. Siehe <a href="commands/OnMessage.htm">OnMessage()</a> für weitere Details.</p>
<p><strong>StrGet(Adresse [, Länge] [, Codierung = Keine ] )</strong>: Kopiert einen String aus einer Speicheradresse unter Beachtung des angegebenen Zeichensatzes. Siehe <a href="commands/StrPutGet.htm">StrGet()</a> für Details.</p>
<p><strong>StrPut(String, Adresse [, Länge] [, Codierung = Keine ] )</strong>: Kopiert einen String in eine Speicheradresse unter Beachtung des angegebenen Zeichensatzes. Siehe <a href="commands/StrPutGet.htm">StrPut()</a> für Details.</p>
<p><strong>RegisterCallback()</strong>: Erstellt eine Maschinencode-Adresse, die, wenn sie aufgerufen wird, den Aufruf an eine Funktion im Script weiterleitet. Siehe <a href="commands/RegisterCallback.htm">RegisterCallback()</a> für Details.</p>
<p><strong>Trim()</strong>: Entfernt Zeichen vom Anfang und/oder Ende eines Strings. Siehe <a href="commands/Trim.htm">Trim()</a> für Details.</p>
<p><strong>VarSetCapacity(VarName [, BenötigteKapazität, Füllbyte])</strong>: Vergrößert die Aufnahmekapazität einer Variable oder gibt deren Speicher frei. Siehe <a href="commands/VarSetCapacity.htm">VarSetCapacity()</a> für Details.</p>
<h3 id="Math">Allgemeine Mathematik</h3>
<p>Hinweis: Mathematische Funktionen geben generell einen leeren Wert (String) zurück, falls einer der eingehenden Parameter nicht numerisch ist.</p>
<p><strong><a name="Abs"></a>Abs(Zahl)</strong>: Gibt den absoluten Wert von <em>Zahl</em> zurück. Der Rückgabewert hat den gleichen Typ wie <em>Zahl</em> (Integer oder Fließkommazahl).</p>
<p><strong><a name="Ceil"></a>Ceil(Zahl)</strong>: Gibt <em>Zahl</em> zurück, aufgerundet auf den nächsten Integer (ohne .00-Suffix). Zum Beispiel ist <code>Ceil(1.2)</code> gleich 2 und <code>Ceil(-1.2)</code> gleich -1.</p>
<p><strong><a name="Exp"></a>Exp(N)</strong>: Gibt <em>e</em> zurück (ungefähr 2.71828182845905), potenziert mit <em>N</em>. Der Parameter <em>N</em> kann negativ sein und einen Dezimalpunkt enthalten. Um neben <em>e</em> noch andere Zahlen zu potenzieren, verwende den <a href="Variables.htm#pow">**-Operator</a>.</p>
<p><strong><a name="Floor"></a>Floor(Zahl)</strong>: Gibt <em>Zahl</em> zurück, abgerundet auf den nächsten Integer (ohne .00-Suffix). Zum Beispiel ist <code>Floor(1.2)</code> gleich 1 und <code>Floor(-1.2)</code> gleich -2.</p>
<p><strong><a name="Log"></a>Log(Zahl)</strong>: Gibt den Logarithmus (Basis 10) von <em>Zahl</em> als Fließkommazahl zurück. Wenn <em>Zahl</em> negativ ist, wird ein leerer String zurückgegeben.</p>
<p><strong><a name="Ln"></a>Ln(Zahl)</strong>: Gibt den natürlichen Logarithmus (Basis e) von <em>Zahl</em> als Fließkommazahl zurück. Wenn <em>Zahl</em> negativ ist, wird ein leerer String zurückgegeben.</p>
<p><strong><a name="Mod"></a>Mod(Dividend, Divisor)</strong>: Modulo. Gibt den Rest zurück, wenn der <em>Dividend</em> durch den <em>Divisor</em> geteilt wird. Das Vorzeichen des Ergebnisses entspricht dem Vorzeichen des ersten Parameters. Zum Beispiel sind <code>Mod(5, 3)</code> und <code>Mod(5, -3)</code> gleich 2, aber <code>Mod(-5, 3)</code> und <code>Mod(-5, -3)</code> gleich -2. Wenn einer der beiden Parameter eine Fließkommazahl ist, wird das Ergebnis ebenfalls eine Fließkommazahl sein. Zum Beispiel ist <code>Mod(5.0, 3)</code> gleich 2.0 und <code>Mod(5, 3.5)</code> gleich 1.5. Ist der zweite Parameter eine 0, gibt die Funktion ein leeres Ergebnis (String) zurück.</p>
<p><strong><a name="Round"></a>Round(Zahl [, N])</strong>: Ist <em>N</em> nicht vorhanden oder eine 0, wird <em>Zahl</em> auf den nächsten Integer gerundet. Ist <em>N</em> eine positive Zahl, wird <em>Zahl</em> auf <em>N</em> Dezimalstellen gerundet. Ist <em>N</em> negativ, wird <em>Zahl</em> auf <em>N</em> Stellen nach links gerundet. Zum Beispiel ist <code>Round(345, -1)</code> gleich 350 und <code>Round(345, -2)</code> gleich 300. Das Ergebnis hat keinen .000-Suffix, wenn <em>N</em> weggelassen wird oder kleiner als 1 ist. Ansonsten ist das Ergebnis ein numerischer String mit genau <em>N</em> Dezimalstellen, anstatt eine reine Fließkommazahl. Man kann das verhindern, wenn man eine weitere mathematische Operation beim Rückgabewert von Round() durchführt; zum Beispiel: <code>Round(3.333, 1)<strong>+0</strong></code>.</p>
<p><strong><a name="Sqrt"></a>Sqrt(Zahl)</strong>: Gibt die Quadratwurzel von <em>Zahl</em> als Fließkommazahl zurück. Wenn <em>Zahl</em> negativ ist, gibt die Funktion ein leeres Ergebnis (String) zurück.</p>
<h3>Trigonometrie</h3>
<p><strong><a name="Sin"></a><a name="Cos"></a><a name="Tan"></a>Sin(Zahl)</strong> | <strong>Cos(Zahl)</strong> | <strong>Tan(Zahl)</strong>: Gibt den trigonometrischen Sinus|Kosinus|Tangens von <em>Zahl</em> zurück. <em>Zahl</em> muss als Bogenmaß angegeben werden.</p>
<p><strong><a name="ASin"></a>ASin(Zahl)</strong>: Gibt den Arkussinus (die Zahl, deren Sinus <em>Zahl</em> ist) als Bogenmaß zurück. Wenn <em>Zahl</em> kleiner als -1 oder größer als 1 ist, gibt die Funktion ein leeres Ergebnis (String) zurück.</p>
<p><strong><a name="ACos"></a>ACos(Zahl)</strong>: Gibt den Arkuskosinus (die Zahl, deren Kosinus <em>Zahl</em> ist) als Bogenmaß zurück. Wenn <em>Zahl</em> kleiner als -1 oder größer als 1 ist, gibt die Funktion ein leeres Ergebnis (String) zurück.</p>
<p><strong><a name="ATan"></a>ATan(Zahl)</strong>: Gibt den Arkustangens (die Zahl, deren Tangens <em>Zahl</em> ist) als Bogenmaß zurück.</p>
<p><strong>Hinweis</strong>: Soll Bogenmaß in Grad umgewandelt werden, multipliziere es mit 180/pi (ungefähr 57.29578). Um ein Grad-Wert in Bogenmaß umzuwandeln, kann es mit pi/180 (ungefähr 0.01745329252) multipliziert werden. Der Wert von pi (ungefähr 3.141592653589793) ist viermal der Arkustangens von 1.</p>
</body>
</html>
