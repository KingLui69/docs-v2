<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<title>Funktionen</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<link href="css/default.css" rel="stylesheet" type="text/css">
</head>

<body>
<h1>Funktionen</h1>

<h2>Inhaltsverzeichnis</h2>
<ul>
  <li><a href="#intro">Einführung und einfache Beispiele</a></li>
  <li><a href="#param">Parameter</a></li>
  <li><a href="#optional">Optionale Parameter</a></li>
  <li><a href="#return">Rückgabewerte an den Aufrufer</a></li>
  <li><a href="#Variadic">Variadische Funktionen</a></li>
  <li><a href="#Locals">Lokale Variablen</a></li>
  <li><a href="#DynCall">Dynamisches Aufrufen einer Funktion </a></li>
  <li><a href="#ShortCircuit">Boolesche Kurzschlussauswertung</a></li>
  <li><a href="#gosub">Subroutinen innerhalb einer Funktion verwenden</a></li>
  <li><a href="#remarks">Return, Exit und allgemeine Bemerkungen</a></li>
  <li><a href="#include">#Include verwenden, um Funktionen in mehreren Scripts einzusetzen</a></li>
  <li><a href="#lib">Funktionsbibliotheken: Standard- und Benutzerbibliothek</a></li>
  <li><a href="#BuiltIn">Interne Funktionen</a></li>
</ul>
<h2><a name="intro" id="intro"></a>Einführung und einfache Beispiele</h2>
<p><a name="define"></a>Eine Funktion ist mit einer Subroutine (<a href="commands/Gosub.htm">GoSub</a>) vergleichbar, die zusätzlich noch Parameter (Eingaben) von ihrem Aufrufer entgegennehmen kann. Bei Bedarf kann eine Funktion dem Aufrufer einen Wert zurückgeben. Betrachte die folgende einfache Funktion, die zwei Zahlen akzeptiert und deren Summe zurückgibt:</p>
<pre>Addieren(x, y)
{
    Return x + y   <em>; "<a href="commands/Return.htm">Return</a>" erwartet einen <a href="Variables.htm#Expressions">Ausdruck</a>.</em>
}</pre>
<p>Das obere Beispiel nennt sich <em>Funktionsdefinition</em>, weil es eine Funktion mit dem Namen "Addieren" erstellt (unabhängig von Groß- und Kleinschreibung) und festlegt, dass jeder, der sie aufruft, genau zwei Parameter (x und y) bereitstellen muss. Um die Funktion aufzurufen, sollte ihr Ergebnis per <a href="commands/SetExpression.htm">Doppelpunkt-Gleich-Operator</a> (<strong><a href="commands/SetExpression.htm">:=</a></strong>) in eine Variable gespeichert werden. Zum Beispiel:</p>
<pre>Var := Addieren(2, 3)  <em>; Speichert die Zahl 5 in Var.</em></pre>
<p>Eine Funktion kann auch aufgerufen werden, ohne ihren Rückgabewert speichern zu müssen:</p>
<pre>Addieren(2, 3)</pre>
<p> In diesem Fall wird der Rückgabewert der Funktion jedoch verworfen; solange die Funktion nicht noch etwas anderes als ihren Rückgabewert erzeugt, würde der Aufruf folglich keinen Sinn machen.</p>
<p>Da ein Funktionsaufruf ein <a href="Variables.htm#Expressions">Ausdruck</a> ist, sollten Variablennamen in ihrer Parameterliste nicht von Prozentzeichen umschlossen sein. Literale Strings sollten hingegen in Anführungszeichen gesetzt werden. Zum Beispiel:</p>
<pre>If <a href="#InStr">InStr</a>(EigeneVar, "fox")
    MsgBox Die Variable EigeneVar enthält das Wort fox.</pre>
<p>Finally, functions may be called in the parameters of any command (except OutputVar parameters). However, parameters that do not support <a href="Variables.htm#Expressions">expressions</a> must use the "% " prefix as in this example:</p>
<pre>MsgBox <strong>%</strong> "Das Ergebnis ist: " <strong>.</strong> Addieren(3, 2)</pre>
<p>Das "%"-Präfix ist auch in Parametern zulässig, die bereits Ausdrücke unterstützen, allerdings wird es einfach ignoriert.</p>
<h2><a name="param" id="param"></a>Parameter</h2>
<p>Beim Definieren einer Funktion werden die Parameter neben dem Funktionsnamen in Klammern aufgelistet (es dürfen sich keine Leerzeichen zwischen den Namen und der öffnenden Klammer befinden). Wenn eine Funktion keine Parameter entgegennehmen soll, musst der Inhalt zwischen den Klammern leer gelassen werden; zum Beispiel: <code>GetCurrentTimestamp()</code>.</p>
<p><a name="ByRef"></a><strong>ByRef-Parameter</strong>: Vom Standpunkt der Funktion aus gesehen, sind Parameter grundsätzlich das gleiche wie <a href="#Locals">lokale Variablen</a>, sofern sie nicht wie folgt als <em>ByRef</em>-Parameter definiert werden:</p>
<pre>Tauschen(ByRef Links, ByRef Rechts)
{
    temp := Links
    Links := Rechts
    Rechts := temp
}</pre>
<p>Im oberen Beispiel bewirkt <em>ByRef</em>, dass jeder Parameter zum Pseudonym der Variable wird, die vom Aufrufer übergeben wurde. Das heißt, dass sich der Parameter und die Aufrufer-Variable auf den gleichen Inhalt im Arbeitsspeicher beziehen. Dadurch kann die Tauschen-Funktion die Aufrufer-Variable ändern, indem sie den Inhalt von <em>Links</em> in <em>Rechts</em> verschiebt und umgekehrt.</p>
<p>Ohne <em>ByRef</em> würden <em>Links</em> und <em>Rechts</em> nur Kopien von den Aufrufer-Variablen sein, wodurch die Tauschen-Funktion keine externe Auswirkung haben würde.</p>
<p>Da <a href="commands/Return.htm">Return</a> nur einen einzigen Wert an den Funktionsaufrufer zurückgeben kann, ist <em>ByRef</em> gut dafür geeignet, zusätzliche Ergebnisse zurückzugeben. Das erreicht man, wenn der Aufrufer dazu gebracht wird, eine Variable zu übergeben (üblicherweise leer), in der die Funktion ein Wert speichern kann.</p>
<p>Bei der Übergabe langer Strings an eine Funktion kann <em>ByRef</em> die Performance erhöhen und Speicherplatz sparen, da keine Kopie des Strings gemacht werden muss. Die Verwendung von <em>ByRef</em> zum Zurückgeben eines langen Strings hat üblicherweise eine höhere Performance als <code>Return LangerString</code>.</p>
<p>If something other than a modifiable variable is passed to a ByRef parameter, the function behaves as though the keyword "ByRef" is absent. For example, <code>Swap(A_Index, i)</code> stores the value of <i>A_Index</i> in <i>i</i>, but the value assigned to <i>Left</i> is discarded once the <i>Swap</i> function returns.</p>
<p>The <a href="#IsByRef">IsByRef()</a> function can be used to determine whether the caller supplied a variable for a given ByRef parameter.</p>
<p>Bekannte Einschränkungen:</p>
<ul>
  <li>It is not possible to pass properties of objects (such as <code>foo.bar</code>), <a href="misc/Clipboard.htm">Clipboard</a> or other <a href="Variables.htm#BuiltIn">built-in variables</a> to a function by reference. Instead, the function acts as though <em>ByRef</em> was omitted.</li>
  <li><a name="recurse"></a>Although a function may call itself recursively, if it passes one of its own <a href="#Locals">local variables</a> or non-ByRef parameters to itself <em>ByRef</em>, the new layer's <em>ByRef </em>parameter will refer to its own local variable of that name rather than the previous layer's. Allerdings tritt dieses Problem nicht auf, wenn eine Funktion sich selbst eine <a href="#Global">globale Variable</a>, <a href="#static">statische Variable</a> oder einen <em>ByRef</em>-Parameter übergibt.</li>
  <li>Wenn bei einem Funktionsaufruf ein Parameter in eine Variable aufgelöst wird (z. B. <code>Var</code> oder <code>++Var</code> oder <code>Var *= 2</code>), kann sich diese Variable durch links und rechts befindliche Parameter noch ändern, bevor sie an die Funktion übergeben wird. Zum Beispiel würde <code>Funktion(Var, Var++)</code> unerwartet eine 0 und 1 übergeben, wenn <em>Var</em> anfangs 0 ist, selbst wenn der erste Parameter der Funktion kein <em>ByRef</em> ist. Dieses unvorteilhafte Verhalten wird möglicherweise in einer zukünftigen Version geändert.</li>
</ul>
<h2 id="optional">Optionale Parameter</h2>
<p>Beim Definieren einer Funktion können beliebig viele Parameter als optional gekennzeichnet werden. This is done by appending the assignment operator followed by a default value. Im folgenden Beispiel ist der Z-Parameter als optional gekennzeichnet:</p>
<pre>Add(X, Y, Z := 0) {
    return X + Y + Z
}</pre>
<p>Übergibt der Aufrufer <strong>drei</strong> Parameter an die obere Funktion, wird der Standardwert von Z ignoriert. Falls der Aufrufer allerdings nur <strong>zwei</strong> Parameter übergibt, erhält Z automatisch den Wert 0.</p>
<p id="missing">Es ist nicht möglich, alleinstehende optionale Parameter in der Mitte der Parameterliste zu verwenden. Das heißt, dass alle Parameter, die sich rechts vom ersten optionalen Parameter befinden, auch als optional gekennzeichnet werden müssen. However, optional parameters may be omitted from the middle of the parameter list when calling the function, as shown below:</p>
<pre>Funktion(1,, 3)
Funktion(X, Y:=2, Z:=0) {  <em>; Beachte, dass Z in diesem Fall weiterhin optional sein muss.</em>
    MsgBox %X%, %Y%, %Z%
}</pre>
<p><a name="OptionalByRef"></a><a href="#ByRef">ByRef parameters</a> also support default values; for example: <code>Funktion(ByRef p1 = "")</code>. Jedes Mal, wenn der Aufrufer einen solchen Parameter weglässt, erstellt die Funktion eine lokale Variable, die den Standardwert enthält; das heißt, dass die Funktion sich so verhält, als würde das Schlüsselwort "ByRef" fehlen.</p>
<p>Für den Standardwert eines Parameters sind folgende Werte zulässig: <code>true</code>, <code>false</code>, a literal integer, a literal floating point number, or a quoted/literal string such as "fox" or "".</p>
<h2 id="return">Rückgabewerte an den Aufrufer</h2>
<p>Wie oben bereits in der <a href="#intro">Einführung</a> beschrieben, kann eine Funktion wahlweise per <a href="commands/Return.htm">Return</a> einen Wert an ihren Aufrufer zurückgeben.</p>
<pre>
Test := returnTest()
MsgBox % Test

returnTest() {
  return 123
}
</pre>
<p>Wenn noch mehr Ergebnisse von einer Funktion zurückgegeben werden sollen, kann man auch <a href="#ByRef">ByRef</a> verwenden:</p>
<pre>
returnByRef(A,B,C)
MsgBox % A "," B "," C

returnByRef(ByRef val1, ByRef val2, ByRef val3)
{
  val1 := "A"
  val2 := 100
  val3 := 1.1
  return
}
</pre>
<pre>
Test1 := returnArray1()
MsgBox % Test1[1] "," Test1[2]

Test2 := returnArray2()
MsgBox % Test2[1] "," Test2[2]

Test3 := returnObject()
MsgBox % Test3.id "," Test3.val

returnArray1() {
  Test := [123,"ABC"]
  return Test
}

returnArray2() {
  x := 456
  y := "EFG"
  return [x, y]
}

returnObject() {
  Test := {id: 789, val: "HIJ"}
  return Test
}
</pre>
<h2 id="Variadic">Variadische Funktionen</h2>
<p>Beim Definieren einer Funktion kann ein Sternchen nach dem letzten Parameter angegeben werden, um die Funktion als variadisch zu kennzeichnen, wodurch sie eine beliebige Anzahl an Parametern akzeptiert:</p>
<pre>Verbinden(sep, <b class="blue">params*</b>) {
    for index,param in params
        str .= param . sep
    Return SubStr(str, 1, -StrLen(sep))
}
MsgBox % Verbinden("`n", "eins", "zwei", "drei")</pre>
<p>Beim Aufrufen einer variadischen Funktion können überschüssige Parameter mithilfe eines Objekts abgerufen werden, das im letzten Parameter der Funktion gespeichert ist. Der erste überschüssige Parameter ist <code><i>params</i>[1]</code>, der Zweite ist <code><i>params</i>[2]</code> und so weiter. Wie bei jedem anderen Standardobjekt auch, kann <code><i>params</i>.MaxIndex()</code> verwendet werden, um den höchsten numerischen Index zu ermitteln (in diesem Fall die Anzahl an Parametern). Sind allerdings keine Parameter vorhanden, gibt MaxIndex einen leeren String zurück.</p>
<p>Hinweise:</p>
<ul>
  <li>Der "variadische" Parameter kann sich nur am Ende der formalen Parameterliste befinden.</li>
  <li><a href="misc/RegExCallout.htm">RegEx-Callouts</a> können nicht variadisch sein; der "variadische" Parameter wird zwar toleriert, aber leer gelassen.</li>
  <li><a href="commands/RegisterCallback.htm">Callbacks</a> übergeben überschüssige Parameter <a href="commands/RegisterCallback.htm#Indirect">per Adresse</a>, anstatt per Array.</li>
</ul>
<h3 id="VariadicCall">Variadische Funktionsaufrufe</h3>
<p>Während variadische Funktionen eine beliebige Anzahl an Parametern <i>akzeptieren</i> können, kann ein Array mit Parametern an <i>jeder</i> Funktion übergeben werden, wenn die gleiche Syntax beim Funktionsaufruf angewendet wird:</p>
<pre>substrings := ["eins", "zwei", "drei"]
MsgBox % Verbinden("`n", <b class="blue">substrings*</b>)</pre>
<p>Hinweise:</p>
<ul>
  <li>Innerhalb des Quell-Arrays beginnt die Nummerierung der Parameter bei 1.</li>
  <li>Optionale Parameter können im Array ganz weggelassen werden.</li>
  <li>Das Array mit Parametern kann benannte Elemente enthalten, wenn eine benutzerdefinierte Funktion aufgerufen wird; in allen anderen Fällen werden benannte Elemente nicht unterstützt.</li>
  <li>Die Zielfunktion kann auch variadisch sein. In diesem Fall werden benannte Elemente auch dann kopiert, wenn sie keinen entsprechenden formalen Parameter haben.</li>
  <li>This syntax can also be used when calling methods or setting or retrieving properties of objects; for example, <code>Object.Property[Params*]</code>.</li>
</ul>
<p>Bekannte Einschränkungen:</p>
<ul>
  <li>Nur der Parameter, der ganz rechts vorkommt, kann auf diese Weise erweitert werden. Zum Beispiel wird <code>Funktion(x, y*)</code> unterstützt, aber nicht <code>Funktion(x*, y)</code>.</li>
  <li>Es dürfen sich keine sichtbaren Zeichen zwischen dem Sternchen (<code>*</code>) und dem Endzeichen der Parameterliste befinden.</li>
</ul>
<h2 id="Locals">Lokale und globale Variablen </h2>
<h3>Lokale Variablen</h3>
<p>Alle Variablen innerhalb einer Funktion sind standardmäßig <em>lokal</em> (außer <a href="#SuperGlobal">superglobale</a> Variablen und interne Variablen wie <a href="misc/Clipboard.htm">Clipboard</a>, <a href="misc/ErrorLevel.htm">ErrorLevel</a> und <a href="Variables.htm#TimeIdle">A_TimeIdle</a>). Der Inhalt jeder lokalen Variable ist nur für Zeilen sichtbar, die sich innerhalb der Funktion befinden. Daher kann eine lokale Variable den gleichen Namen einer globalen Variable haben, aber mit unterschiedlichem Inhalt. Außerdem sind alle lokalen Variablen bei jedem Funktionsaufruf zu Beginn leer.</p>
<h3 id="Global">Globale Variablen</h3>
<p>Um innerhalb einer Funktion auf eine vorhandene globale Variable zu verweisen (oder eine neue zu erstellen), deklariere die Variable als global, bevor man sie verwendet. Zum Beispiel:</p>
<pre>LogToFile(TextToLog)
{
    <strong>global</strong> LogFileName  <em>; This global variable was previously given a value somewhere outside this function.</em>
    FileAppend, %TextToLog%`n, %LogFileName%
}</pre>
<p><a name="AssumeGlobal"></a><strong>Modus für die globale Ansicht</strong>: If a function needs to access or create a large number of global variables, it can be defined to assume that all its variables are global (except its parameters) by making its first line the word "global". Zum Beispiel:</p>
<pre>SetDefaults()
{
    <strong>global</strong>
    MyGlobal := 33  <em>; Assigns 33 to a global variable, first creating the variable if necessary.</em>
    local x, y:=0, z  <em>; Local variables must be declared in this mode, otherwise they would be assumed global.</em>
}</pre>
<p>This assume-global mode can also be used by a function to create a global <a href="misc/Arrays.htm">pseudo-array</a>, such as a loop that assigns values to <code>Array%A_Index%</code>.</p>
<p id="SuperGlobal"><strong>Super-global variables</strong>: Geschieht eine globale Deklaration außerhalb einer Funktion, gilt sie standardmäßig für alle Funktionen. Dadurch wird verhindert, dass die Variablen jedesmal in einer Funktion neu deklariert werden müssen. Hat die Funktion allerdings bereits einen Parameter oder eine lokale Variable mit dem gleichen Namen, wird diese Vorrang vor der globalen Variable haben. Variables created by the <a href="Objects.htm#Custom_Classes">class</a> keyword are also super-global.</p>
<h3 id="static">Statische Variablen</h3>
<p>Statische Variablen sind immer indirekt lokal. Der Unterschied ist aber, dass ihre Werte zwischen den Funktionsaufrufen erhalten bleiben. Zum Beispiel:</p>
<pre>LogToFile(TextToLog)
{
    <strong>static</strong> LoggedLines := 0
    LoggedLines += 1  <em>; Maintain a tally locally (its value is remembered between calls).</em>
    global LogFileName
    FileAppend, %LoggedLines%: %TextZuLog%`n, %LogDateiname%
}</pre>
<p><a name="InitStatic"></a>A static variable may be initialized on the same line as its declaration by following it with <code>:=</code> followed by any <a href="Variables.htm#Expressions">expression</a>. Zum Beispiel: <code>static X:=0, Y:="fox"</code>. Each static variable is initialized only once. Static variables are initialized in the order that they appear in the script file, but before the script's auto-execute section.</p>
<p><a name="AssumeStatic"></a><strong>Assume-static mode</strong>: A function may be defined to assume that all its variables are static (except its parameters) by making its first line the word "static". Zum Beispiel:</p>
<pre>StatischesArrayAbrufen(Elementnummer)
{
    <strong>static</strong>
    static ErsterAufruf := true  <em>; Die Initialisierung einer statischen Deklaration wird weiterhin nur einmal ausgeführt (beim Start).</em>
    If ErsterAufruf  <em>; Erstellt ein statisches Array beim ersten Aufruf, aber nicht mehr danach.</em>
    {
        ErsterAufruf := false
        Loop 10
            StatischesArray%A_Index% := "Wert #" . A_Index
    }
    Return StatischesArray%Elementnummer%
}</pre>
<p>Im Modus für die statische Ansicht muss jede Variable, die nicht statisch sein soll, als lokal oder global deklariert werden.</p>
<h3>Mehr über lokale und globale Variablen</h3>
<p>Es können mehrere Variablen in einer Zeile deklariert werden, indem sie wie im folgenden Beispiel durch Kommas getrennt werden:</p>
<pre>global LogFileName, MaxRetries := 5
static TotalAttempts := 0, PrevResult</pre>
<p><a name="DeclareInit"></a>A local or global variable may be initialized on the same line as its declaration by following it with <code>:=</code> followed by any <a href="Variables.htm#Expressions">expression</a>. Unlike <a href="#InitStatic">static initializers</a>, the initializers of locals and globals execute every time the function is called, but only if/when the flow of control actually reaches them. In other words, a line like <code>local x := 0</code> has the same effect as writing two separate lines: <code>local x</code> followed by <code>x := 0</code>.</p>
<p>Da die Wörter <em>local</em>, <em>global</em> und <em>static</em> unmittelbar beim Start des Scripts verarbeitet werden, kann eine Variable nicht per <a href="commands/IfExpression.htm">IF-Anweisung</a> bedingt deklariert werden. Das heißt, dass eine Deklaration innerhalb eines IF- oder ELSE-<a href="commands/Block.htm">Blocks</a> für alle Zeilen zwischen der Deklaration und der schließenden Funktionsklammer bedingungslos wirksam wird. Beachte zudem, dass es zurzeit nicht möglich ist, eine dynamische Variable wie <code>global Array%i%</code> zu deklarieren.</p>

<h2 id="DynCall"><a name="dynamic"></a>Dynamisches Aufrufen einer Funktion </h2>
<p>A function (even a <a href="#BuiltIn">built-in function</a>) may be called dynamically via percent signs. For example, <code>%Var%(x, "fox") </code>would call the function whose name is contained in <em>Var</em>. Ebenso würde <code>Funktion%A_Index%()</code> Funktion1(), Funktion2() und so weiter aufrufen, abhängig vom aktuellen Wert in A_Index.</p>
<p><em>Var</em> in <code>%Var%()</code> can contain a function name, <a href="objects/Func.htm">function reference</a> or <a href="Objects.htm#Objects_as_Functions">object imitating a function</a>. Falls die Funktion nicht existiert, wird stattdessen die __Call-Meta-Funktion des <a href="Objects.htm#Default_Base_Object">Standard-base-Objekts</a> aufgerufen.</p>
<p>Kann die Funktion aufgrund einer der unten genannten Gründe nicht aufgerufen werden, stoppt die Auswertung des Ausdrucks mit dem Aufruf unauffällig und frühzeitig, was möglicherweise zu widersprüchlichen Ergebnissen führen kann:</p>
<ul>
  <li>Aufruf einer nicht vorhandenen Funktion, dass mithilfe von <code>If <a href="#IsFunc">IsFunc</a>(VariableMitFunktionsname)</code> verhindert werden kann. Die <a href="#define">Definition</a> der aufgerufenen Funktion (außer <a href="#BuiltIn">interne Funktionen</a>) muss direkt im Script vorhanden sein. Zum Beispiel per <a href="commands/_Include.htm">#Include</a> oder nicht-dynamischen Aufruf einer <a href="#lib">Bibliotheksfunktion</a>.</li>
  <li>Übergabe von zu wenigen Parametern, dass mittels Überprüfung des Rückgabewertes von <a href="#IsFunc">IsFunc()</a> verhindert werden kann (das ist die Anzahl an vorgeschriebenen Parametern plus 1). Hinweis: Passing too many parameters is tolerated; each extra parameter is fully evaluated (including any calls to functions) and then discarded.</li>
</ul>
<p>Beachte, dass ein dynamischer Aufruf einer Funktion etwas langsamer ist als ein normaler Aufruf, weil normale Aufrufe aufgelöst (nachgeschlagen) werden, bevor die Ausführung des Scripts beginnt.</p>
<h2 id="ShortCircuit">Boolesche Kurzschlussauswertung</h2>
<p>Sobald <em>AND, OR</em> und der <a href="Variables.htm#ternary">ternäre Operator</a> innerhalb eines <a href="Variables.htm#Expressions">Ausdrucks</a> verwendet werden, werden sie kurzgeschlossen, um die Performance zu steigern (unabhängig davon, ob Funktionsaufrufe vorhanden sind). Beim Kurzschließen werden nur Bereiche des Ausdrucks ausgewertet, die Einfluss auf das Endergebnis haben. Um das Konzept näher zubringen, schaue dir folgendes Beispiel an:</p>
<pre>If (FarbName &lt;&gt; "" AND not FindeFarbe(FarbName))
    MsgBox %FarbName% konnte nicht gefunden werden.</pre>
<p>Im oberen Beispiel wird die Funktion FindeFarbe() nie aufgerufen, wenn die <em>FarbeName</em>-Variable leer ist. Das liegt daran, dass die linke Seite von <em>AND</em> als <em>falsch</em> gewertet wird, wodurch die rechte Seite nicht mehr in der Lage wäre, das Endergebnis auf <em>wahr</em> zu bringen.</p>
<p>Dieses Verhalten führt dazu, dass Nebeneffekte von einer Funktion (wie das Ändern des Inhalts einer globalen Variable) nie auftreten werden, wenn diese Funktion auf der rechten Seite von <em>AND</em> oder <em>OR</em> aufgerufen wird.</p>
<p>Beachte außerdem, dass die Kurzschlussauswertung stufenweise verschachtelte <em>AND</em>s und <em>OR</em>s durchgeht. Im Ausdruck des folgenden Beispiels wird nur der Vergleich ganz links durchgeführt, wenn <em>FarbName</em> leer ist. Die linke Seite würde ausreichen, um das Endergebnis zu bestimmen:</p>
<pre>If (FarbName = "" <u>OR</u> FindeFarbe(FarbName, Region1) <u>OR</u> FindeFarbe(FarbName, Region2))
    break   <em>; Nichts zu durchsuchen oder Übereinstimmung gefunden.</em></pre>
<p>Wie aus dem oberen Beispiel ersichtlich wird, sollten aufwendige Funktionen generell auf der rechten Seite von <em>AND</em> oder <em>OR</em> aufgerufen werden, um die Performance zu erhöhen. Diese Technik kann auch dazu genutzt werden, einen Funktionsaufruf zu verhindern, wenn ein ungeeigneter Wert an einen Parameter übergeben wird, wie z. B. ein leerer String.</p>
<p>The <a href="Variables.htm#ternary">ternary conditional operator (?:)</a> also short-circuits by not evaluating the losing branch.</p>
<h2 id="gosub">Subroutinen innerhalb einer Funktion verwenden</h2>
<p>Es ist möglich, Subroutinen innerhalb einer Funktion anzugeben; <a href="#define">Definitionen</a> von anderen Funktionen sind nicht möglich. Sie können, wie jede andere Subroutine auch, per <a href="commands/Gosub.htm">GoSub</a> aufgerufen und per <a href="commands/Return.htm">Return</a> geschlossen werden (in diesem Fall gilt das Return für GoSub und nicht für die Funktion).</p>
<p><a name="GosubPublic"></a>Verwendet eine Funktion den <a href="commands/Gosub.htm">GoSub</a>-Befehl zum Anspringen einer öffentlichen Subroutine (die sich außerhalb der Funktionsklammern befindet), sind alle äußeren Variablen global und die eigenen <a href="#Locals">lokalen Variablen</a> der Funktion erst zugänglich, wenn die Subroutine durchgeführt wurde. Allerdings wird A_ThisFunc weiterhin den Namen der Funktion enthalten.</p>
<p>Der <a href="commands/Goto.htm">Goto</a>-Befehl kann nicht verwendet werden, um innerhalb einer Funktion von innen nach außen zu springen. Allerdings ist es möglich, dass eine Funktion per <a href="commands/Gosub.htm">GoSub</a> eine externe/öffentliche Subroutine anspringen und von dort aus per Goto weiterspringen kann.</p>
<p>Auch wenn von <a href="commands/Goto.htm">Goto</a> generell abgeraten wird, kann er innerhalb einer Funktion nützlich sein, um in der gleichen Funktion von einer Position zu einer anderen zu springen. Das kann dabei helfen, komplexe Funktionen mit mehreren Rückgabepunkten zu vereinfachen, die einige Säuberungsaktionen machen müssen, bevor sie ausgeführt werden.</p>
<p>Eine Funktion kann extern-aufgerufene Subroutinen wie <a href="commands/SetTimer.htm">Timer</a>, <a href="commands/Gui.htm#label">g-Label</a> und <a href="commands/Menu.htm">Menüpunkte</a> enthalten. Das wird normalerweise gemacht, um sie für die Verwendung mit <a href="commands/_Include.htm">#Include</a> in eine separate Datei zu hinterlegen, damit sie den <a href="Scripts.htm#auto">automatischen Ausführungsbereich</a> nicht stören. Allerdings gelten folgende Einschränkungen:</p>
<ul>
  <li>Solche Subroutinen sollten nur <a href="#static">statische</a> und <a href="#Global">globale</a> Variablen verwenden (keine <a href="#Locals">lokalen</a>), immer wenn deren Funktionen normal aufgerufen werden. Der Grund ist, dass der <a href="misc/Threads.htm">Thread</a> einer Subroutine, der den Thread eines Funktionsaufrufs unterbricht (oder umgekehrt), in der Lage wäre, die Werte von lokalen Variablen zu ändern, welche vom unterbrochenen Thread gesehen werden. Jedes Mal, wenn eine Funktion zu ihrem Aufrufer zurückkehrt, werden all ihre lokale Variablen leer gemacht, um deren Speicher freizugeben.</li>
  <li>Solche Subroutinen sollten nur <a href="#Global">globale Variablen</a> (keine <a href="#static">statischen Variablen</a>) als <a href="commands/Gui.htm#var">GUI-Steuerelement-Variablen</a> verwenden.</li>
  <li>Wenn eine Funktion von einem Subroutine-<a href="misc/Threads.htm">Thread</a> angesprungen wird, werden alle Verweise auf <a href="misc/Arrays.htm">dynamische Variablen</a>, die von diesem Thread erstellt wurden, als <a href="#Global">globale Variablen</a> behandelt (einschließlich Befehle, die Arrays erstellen). Similarly, <a href="misc/Labels.htm">local labels</a> cannot be referenced dynamically.</li>
</ul>
<h2 id="remarks">Return, Exit und allgemeine Bemerkungen</h2>
<p>Erreicht der Ausführungsablauf innerhalb einer Funktion die schließende Funktionsklammer, ohne auf ein <a href="commands/Return.htm">Return</a> gestoßen zu sein, endet die Funktion und gibt ihren Aufrufer einen leeren String zurück. Ein leerer Wert wird auch zurückgegeben, wenn der Parameter von <a href="commands/Return.htm">Return</a> ausdrücklich weggelassen wird.</p>
<p>Beendet eine Funktion den <a href="misc/Threads.htm">aktuellen Thread</a> per <a href="commands/Exit.htm">Exit</a>-Befehl, erhält ihr Aufrufer überhaupt keinen Rückgabewert. Zum Beispiel würde die Anweisung <code>Var := Addieren(2, 3)</code> <code>Var</code> unverändert lassen, wenn <code>Add()</code> beendet wird. Das Gleiche passiert, wenn die Funktion einen Laufzeitfehler verursacht, wie das <a href="commands/Run.htm">Ausführen</a> einer nicht vorhandenen Datei (nur wenn <a href="commands/Run.htm#UseErrorLevel">UseErrorLevel</a> nicht aktiv ist).</p>
<p>Eine Funktion kann den Wert von <a href="misc/ErrorLevel.htm">ErrorLevel</a> ändern, um einen zusätzlichen Wert zurückzugeben, der sich leicht merken lässt.</p>
<p>Um eine Funktion mit einem oder mehreren leeren Strings aufzurufen, verwende zwei Anführungszeichen wie folgt: <code>FindeFarbe(FarbName, "")</code>.</p>
<p>Da ein Funktionsaufruf keinen neuen <a href="misc/Threads.htm">Thread</a> startet, gelten alle von der Funktion durchgeführten Änderungen an den Einstellungen wie <a href="commands/SendMode.htm">SendMode</a> oder <a href="commands/SetTitleMatchMode.htm">SetTitleMatchMode</a> auch für den Aufrufer.</p>
<p>Der Aufrufer kann der Funktion nicht vorhandene Variablen oder <a href="misc/Arrays.htm">Array</a>-Elemente übergeben. Das ist besonders nützlich, wenn die Funktion vom entsprechenden Parameter erwartet, ein <a href="#ByRef">ByRef</a> zu sein. Zum Beispiel würde <code>GetNextLine(LeeresArray%i%)</code> die Variable <code>LeeresArray%i%</code> automatisch als <a href="#Locals">lokale</a> oder globale Variable erstellen (abhängig davon, ob der Aufrufer sich in einer Funktion befindet und ob der <a href="#AssumeGlobal">Modus für die globale Ansicht</a> wirksam ist).</p>
<p>Innerhalb einer Funktion zeigt <a href="commands/ListVars.htm">ListVars</a> deren <a href="#Locals">lokalen Variablen</a> mit Inhalt an. Das kann dabei helfen, ein Script zu debuggen.</p>
<h2>Stil und Namenskonventionen</h2>
<p>Komplexe Funktionen können besser lesbar und verwaltbar gemacht werden, wenn deren Variablen eindeutige Präfixe angefügt werden. Durch Hinzufügen von beispielsweise "p" oder "p_" am Anfang jeden Parameters ist seine besondere Art besser erkennbar, besonders wenn eine Funktion sehr viele <a href="#Locals">lokale Variablen</a> hat. Ebenso kann das Präfix "r" oder "r_" für <a href="#ByRef">ByRef-Parameter</a> und "s" oder "s_" für <a href="#static">statische Variablen</a> verwendet werden.</p>
<p>Bei Bedarf kann der "<a href="commands/Block.htm#otb">One True Brace Style</a>" verwendet werden, um Funktionen zu definieren. Zum Beispiel:</p>
<pre>Addieren(x, y) <strong>{</strong>
    Return x + y
<strong>}</strong></pre>
<h2 id="include">#Include verwenden, um Funktionen in mehreren Scripts einzusetzen</h2>
<p>Die <a href="commands/_Include.htm">#Include</a>-Direktive kann verwendet werden (<em>auch am Anfang des Scripts</em>), um Funktionen aus einer externen Datei zu laden.</p>
<p>Erklärung: Erreicht der Ausführungsablauf des Scripts eine Funktionsdefinition, wird sie übersprungen (verwendet eine sofortige Methode) und setzt die Ausführung bei der Zeile nach der schließenden Klammer fort. Folglich kann die Ausführung nie in eine Funktion geraten, noch beeinflussen eine oder mehrere Funktionen am Anfang des Scripts den <a href="Scripts.htm#auto">automatischen Ausführungsbereich</a>.</p>
<h2><a name="lib" id="lib"></a>Funktionsbibliotheken: Standard- und Benutzerbibliothek</h2>
<p>Ein Script kann eine Funktion aus einer externen Datei aufrufen, ohne dabei <a href="commands/_Include.htm">#Include</a> zu verwenden. Damit das funktioniert, muss eine Datei mit gleichem Namen in einem der folgenden Bibliotheksverzeichnissen vorkommen:</p>
<pre><a href="Variables.htm#ScriptDir">%A_ScriptDir%</a>\Lib\  <em>; Local library.</em>
<a href="Variables.htm#MyDocuments">%A_MyDocuments%</a>\AutoHotkey\Lib\  <em>; User library.</em>
path-to-the-currently-running-AutoHotkey.exe\Lib\  <em>; Standard library.</em></pre>
<p>Ruft ein Script beispielsweise eine nicht vorhandene Funktion <code>EigeneFunktion()</code> auf, sucht das Programm nach einer Datei namens "EigeneFunktion.ahk" in der Benutzerbibliothek. Ergibt die Suche keine Treffer, wird die Standardbibliothek durchsucht. Falls sie immer noch nicht gefunden wird und der Funktionsname ein Unterstrich enthält (z. B. <code>EigenerPräfix_EigeneFunktion</code>), durchsucht das Programm beide Bibliotheken nach einer Datei namens <code>EigenerPräfix.ahk</code> und lädt sie, falls sie existiert. Dadurch kann <code>EigenerPräfix.ahk</code> sowohl die Funktion <code>EigenerPräfix_EigeneFunktion</code> als auch andere verwandte Funktionen enthalten, deren Namen mit <code>EigenerPräfix_</code> beginnen.</p>
<p>The local library is searched before the user library and standard library.</p>
<p>In der Regel kann eine Bibliotheksdatei nur eine Funktion enthalten, die den Namen der Datei hat. Allerdings kann sie auch private Funktionen und Subroutinen enthalten, die nur von ihr aufgerufen werden. Die Namen solcher Funktionen sollten jedoch gut durchdacht sein, da sie weiterhin im globalen Namensraum vorhanden sind; das heißt, dass sie von überall im Script aufgerufen werden können.</p>
<p>Verwendet eine Bibliotheksdatei <a href="commands/_Include.htm">#Include</a>, ist das Arbeitsverzeichnis für #Include das Verzeichnis der Bibliotheksdatei. Dadurch ist es möglich, eine Umleitung zu einer größeren Bibliotheksdatei zu erstellen, die diese Funktion und Ähnliches enthält.</p>
<p>Der <a href="Scripts.htm#ahk2exe">Script-Compiler (ahk2exe)</a> unterstützt auch Bibliotheksfunktionen. Allerdings ist eine Kopie von AutoHotkey.exe im Verzeichnis oberhalb des Compiler-Verzeichnisses notwendig (was normalerweise der Fall ist). Sollte AutoHotkey.exe fehlen, wird der Compiler weiterhin funktionieren, jedoch werden die Bibliotheksfunktionen nicht mehr automatisch eingefügt.</p>
<p>Funktionen, die von einer Bibliothek eingefügt worden sind, funktionieren genauso gut wie andere Funktionen, da sie geladen werden, bevor das Script ausgeführt wird.</p>
<h2 id="BuiltIn">Interne Funktionen</h2>
<p>Jeder optionale Parameter, der am Ende der Parameterliste einer internen Funktion vorkommt, kann vollständig weggelassen werden. Zum Beispiel ist <code>WinExist("Unbenannt - Editor")</code> gültig, weil die anderen drei Parameter als leer angesehen werden.</p>
<p>Eine interne Funktion kann überschrieben werden, indem man eine eigene Funktion mit dem gleichen Namen definiert. Zum Beispiel könnte man anstelle der normalen WinExist()-Funktion eine selbstdefinierte Funktion verwenden. Allerdings kann danach die originale Funktion nicht mehr aufgerufen werden.</p>
<p>Externe Funktionen, die sich in DLL-Dateien befinden, können per <a href="commands/DllCall.htm">DllCall()</a> aufgerufen werden.</p>
<h3>Häufig verwendete Funktionen</h3>
<p><strong><a name="FileExist"></a>FileExist(Dateimuster)</strong>: Gibt einen leeren String zurück, wenn <em>Dateimuster</em> nicht existiert (<em>Dateimuster</em> befindet sich im <a href="Variables.htm#WorkingDir">A_WorkingDir</a>-Verzeichnis, solange kein absoluter Pfad angegeben ist). Ansonsten wird ein <a href="commands/FileGetAttrib.htm#attrib">String mit Attributen</a> (eine Teilmenge von "RASHNDOCT") von der ersten gefundenen Datei oder des ersten gefundenen Ordners zurückgegeben. Hat die Datei keine Attribute (was sehr selten ist), wird "X" zurückgegeben. <em>Dateimuster</em> kann der exakte Name einer Datei oder eines Ordners sein, oder Platzhalter (* oder ?) enthalten. Da ein leerer String als "falsch" angesehen wird, kann der Rückgabewert der Funktion immer als Boolscher Scheinwert verwendet werden. Zum Beispiel würde die Anweisung <code>If FileExist("C:\Eigene Datei.txt")</code> als wahr angesehen werden, wenn die Datei vorhanden ist. Ebenso würde die Anweisung <code>If InStr(FileExist("C:\Eigene Ordner"), "D")</code> nur als wahr angesehen werden, wenn die Datei existiert <em>und</em> ein Verzeichnis ist. Corresponding command: <a href="commands/FileGetAttrib.htm">FileGetAttrib</a>.</p>
<p id="DirExist"><strong>DirExist(FilePattern)</strong>: Equivalent to <a href="#FileExist">FileExist()</a>, but returns a blank value (empty string) if <em>FilePattern</em> is not a directory.</p>
<p><strong><a name="GetKeyState"></a>GetKeyState(<a href="KeyList.htm">Tastenname</a> [, "P"</strong> oder <strong>"T"])</strong>: See <a href="commands/GetKeyState.htm">GetKeyState</a>.</p>
<p><strong><a name="InStr"></a>InStr(Heuhaufen, Nadel [, Zeichengenauigkeit = false, Startposition = 1, Vorkommen = 1])</strong>: Gibt die Position des Strings <em>Nadel</em> zurück, der im String <em>Heuhaufen</em> vorkommt. Position 1 is the first character; this is because 0 is synonymous with "false", making it an intuitive "not found" indicator. If the parameter <em>CaseSensitive</em> is omitted or false, the search is not case sensitive (the method of insensitivity depends on <a href="commands/StringCaseSense.htm">StringCaseSense</a>); otherwise, the case must match exactly. If <em>StartingPos</em> is omitted, it defaults to 1 (the beginning of <em>Haystack</em>). Otherwise, specify 2 to start at <em>Haystack</em>'s second character, 3 to start at the third, etc. If <em>StartingPos</em> is beyond the length of <em>Haystack</em>, 0 is returned. If <em>StartingPos</em> is negative, the search is conducted in reverse (right-to-left) beginning at that position counting from the right. Regardless of the value of <em>StartingPos</em>, the returned position is always relative to the first character of <em>Haystack</em>. Zum Beispiel wäre die Position von "abc" in "123abc789" immer 4. Specify 2 for <i>Occurrence</i> to return the position of the second match, 3 for the third match, etc. Related: <a href="commands/RegExMatch.htm">RegExMatch()</a>.</p>
<p><strong>RegExMatch(Heuhaufen, NadelRegEx [, AusgabeVar = "", Startposition = 1])</strong>: See <a href="commands/RegExMatch.htm">RegExMatch</a></span><a href="commands/RegExMatch.htm">()</a>.</p>
<p><strong>RegExReplace(Haystack, NeedleRegEx [, Replacement = "", OutputVarCount = "", Limit = -1, StartingPos = 1])</strong></span>: See <span class="CommandSyntax"><a href="commands/RegExReplace.htm">RegExReplace</a></span><a href="commands/RegExReplace.htm">()</a>.</p>
<p><strong><a name="SubStr"></a>SubStr(String, StartingPos [, Length])</strong>: Copies a substring from <em>String</em> starting at <em>StartingPos</em> and proceeding rightward to include at most <em>Length</em> characters (if <em>Length</em> is omitted, it defaults to "all characters"). For <em>StartingPos</em>, specify 1 to start at the first character, 2 to start at the second, and so on (if <em>StartingPos</em> is beyond <em>String</em>'s length, an empty string is returned). If <em>StartingPos</em> is negative, it is considered to be an offset from the end of the string. For example, -1 extracts the last character and -2 extracts the two last characters (but if <em>StartingPos</em> tries to go beyond the left end of the string, the extraction starts at the first character). <em>Length</em> is the maximum number of characters to retrieve (fewer than the maximum are retrieved whenever the remaining part of the string is too short). Specify a negative <em>Length </em>to omit that many characters from the end of the returned string (an empty string is returned if all or too many characters are omitted). Related: <a href="commands/RegExMatch.htm">RegExMatch()</a>.</p>
<p><strong><a name="StrLen"></a>StrLen(String)</strong>: Gibt die Länge von <em>String</em> zurück. If <em>String</em> is a variable to which <a href="misc/Clipboard.htm#ClipboardAll">ClipboardAll</a> was previously assigned, its total byte size divided by 2 is returned.</p>
<p><strong><a name="StrSplit"></a>StrSplit(String [, Delimiters, OmitChars])</strong> Separates a string into an array of substrings using the specified delimiters. See <a href="commands/StrSplit.htm">StrSplit()</a> for details.</p>
<p><strong><a name="WinActive"></a>WinActive([Fenstertitel, Fenstertext, Titelausnahme, Textausnahme])</strong>: Gibt die Eindeutige ID (HWND) des aktiven Fensters zurück, wenn es die  angegebenen Kriterien erfüllt. See <a href="commands/WinActive.htm">WinActive()</a> for details.</p>
<p><strong><a name="WinExist"></a>WinExist([Fenstertitel, Fenstertext, Titelausnahme, Textausnahme])</strong>: Gibt die <a href="commands/WinGet.htm">eindeutige ID (HWND)</a> des ersten übereinstimmenden Fensters zurück. Siehe <a href="commands/WinExist.htm">WinExist()</a> für Details.</p>
<h3>Verschiedene Funktionen</h3>
<p id="Ord"><strong>Ord(String)</strong>: Returns the ordinal value of the first Unicode character in <em>String</em>. This is typically a number between 1 and 65535 (0xFFFF), but can be a number between 0x10000 and 0x10FFFF if <em>String</em> begins with a supplementary character (encoded as a UTF-16 surrogate pair). Ist <em>String</em> leer, wird 0 zurückgegeben.</p>
<p><strong><a name="Chr"></a>Chr(Zahl)</strong>: Returns the character corresponding to the Unicode character code indicated by <em>Number</em>. Liegt <em>Zahl</em> außerhalb des gültigen Bereichs der Zeichencodes, wird ein leerer String zurückgegeben. Häufig verwendete Zeichencodes sind 9 (Tabulator), 10 (LF), 13 (CR), 32 (Leerzeichen), 48-57 (die Zahlen von 0 bis 9), 65-90 (Großbuchstaben von A bis Z) und 97-122 (Kleinbuchstaben von a bis z). Numbers in the range 0x10000 to 0x10FFFF produce rarely-used supplementary characters (encoded as a UTF-16 surrogate pair).</p>
<p><strong>DllCall()</strong>: Ruft eine Funktion innerhalb einer DLL-Datei auf, wie z. B. eine API-Funktion von Windows. Siehe <a href="commands/DllCall.htm">DllCall()</a> für Details.</p>
<p><strong>FileOpen()</strong>: Ermöglicht eine objektorientierte Dateibearbeitung. Siehe <a href="commands/FileOpen.htm">FileOpen()</a> für Details.
<p><strong><a name="Func"></a>Func(FunctionName)</strong>: If <em>FunctionName</em> does not exist explicitly in the script (by means such as <a href="commands/_Include.htm">#Include</a> or a non-dynamic call to a <a href="#lib">library function</a>), Func() returns 0. Otherwise, it returns a <a href="Objects.htm#Function_References">reference to the function</a>. This can be used to call the function or retrieve <a href="objects/Func.htm">information</a> such as the minimum and maximum number of parameters.</p>
<p><strong><a name="GetKeyName"></a>GetKeyName(Key), GetKeyVK(Key), GetKeySC(Key)</strong>: Retrieves the name/text, virtual key code or scan code of a key. <em>Key</em> can be a VK or SC code, such as "vkA2" or "sc01D", a combination of both, or a key name. For example, both <code>GetKeyName("vk1B")</code> and <code>GetKeyName("Esc")</code> return "Escape", while <code>GetKeyVK("Esc")</code> returns 27.</p>
<p><strong><a name="IsByRef"></a>IsByRef(Var)</strong>: Returns 1 if <em>Var</em> is a ByRef parameter and the caller supplied a variable; or 0 if <em>Var</em> is any other kind of variable.</p>
<p><strong><a name="IsFunc"></a>IsFunc(FunctionName)</strong>: If <em>FunctionName</em> does not exist explicitly in the script (by means such as <a href="commands/_Include.htm">#Include</a> or a non-dynamic call to a <a href="#lib">library function</a>), IsFunc() returns 0. Ansonsten gibt sie die minimale Anzahl an Parametern zurück, addiert mit 1 (also 1 für eine Funktion ohne Parameter, 2 für eine Funktion mit einem Parameter und so weiter). For example, the statements <code>if IsFunc("MyFunc")</code> and <code>if IsFunc(VarContainingFunctionName)</code> would be true if the function exists, and false otherwise. <i>FunctionName</i> can be a function reference instead of a name. Siehe auch: <a href="#DynCall">Dynamic function-call</a>, <a href="Variables.htm#ThisFunc">A_ThisFunc</a></p>
<p><strong><a name="IsLabel"></a>IsLabel(LabelName)</strong>: Returns a non-zero number if <em>LabelName </em>exists in the script as a <a href="commands/Gosub.htm">subroutine</a>, <a href="Hotkeys.htm">hotkey</a>, or <a href="Hotstrings.htm">hotstring</a> (do not include the trailing colon(s) in <em>LabelName</em>). Zum Beispiel würde die Anweisung <code>If IsLabel(VariableMitLabelnamen)</code> als wahr angesehen werden, wenn das Label vorhanden ist. Das ist nützlich, um Laufzeitfehler zu unterdrücken, wenn man ein dynamisches Label in Befehlen wie <a href="commands/Gosub.htm">Gosub</a>, <a href="commands/Hotkey.htm">Hotkey</a>, <a href="commands/Menu.htm">Menu</a> und <a href="commands/Gui.htm">Gui</a> angibt. Siehe auch: <a href="misc/Labels.htm">Label</a>.</p>
<p><strong><a name="IsObject"></a>IsObject()</strong>: Determines if a value is an object. Siehe auch: <a href="Objects.htm">Objects</a>.</p>
<p><strong>ListView and </strong><strong>TreeView functions</strong>: See the <a href="commands/ListView.htm">ListView</a> and <a href="commands/TreeView.htm">TreeView</a> pages for details.</p>
<p><strong><a name="NumGet"></a>NumGet(VarOderAdresse [, Offset = 0][, Typ = "UPtr"])</strong>: See <a href="commands/NumGet.htm">NumGet</a>.</p>
<p><strong><a name="NumPut"></a>NumPut(Nummer, VarOderAdresse [, Offset = 0][, Typ = "UPtr"])</strong>: See <a href="commands/NumPut.htm">NumPut</a>.</p>
<p><strong>OnMessage(Nachrichtennummer [, "Funktionsname"])</strong>: Überwacht eine Nachricht/ein Ereignis. Siehe <a href="commands/OnMessage.htm">OnMessage()</a> für weitere Details.</p>
<p><strong>StrGet(Address [, Length] [, Encoding = None ] )</strong>: Copies a string from a memory address, optionally converting it between code pages. See <a href="commands/StrPutGet.htm">StrGet()</a> for details.</p>
<p><strong>StrPut(String, Address [, Length] [, Encoding = None ] )</strong>: Copies a string to a memory address, optionally converting it between code pages. See <a href="commands/StrPutGet.htm">StrPut()</a> for details.</p>
<p><strong>RegisterCallback()</strong>: Erstellt eine Maschinencode-Adresse, die beim Aufrufen den Aufruf zu einer Funktion im Script umleitet. Siehe <a href="commands/RegisterCallback.htm">RegisterCallback()</a> für Details.</p>
<p><strong>Trim()</strong> Trims characters from the beginning and/or end of a string. See <a href="commands/Trim.htm">Trim()</a> for details.</p>
<p><strong>VarSetCapacity(VarName [, BenötigteKapazität, Füllbyte])</strong>: Vergrößert die Aufnahmekapazität einer Variable oder gibt deren Speicher frei. Siehe <a href="commands/VarSetCapacity.htm">VarSetCapacity()</a> für Details.</p>
<h3 id="Math">Allgemeine Mathematik </h3>
<p>Hinweis: Mathematische Funktionen geben generell einen leeren Wert (String) zurück, falls einer der eingehenden Parameter nicht numerisch ist.</p>
<p><strong><a name="Abs"></a>Abs(Zahl)</strong>: Gibt den absoluten Wert von <em>Zahl</em> zurück. Der Rückgabewert hat den gleichen Typ wie <em>Zahl</em> (Integer oder Fließkommazahl).</p>
<p><strong><a name="Ceil"></a>Ceil</strong><strong>(Number)</strong>: Returns <em>Number</em> rounded up to the nearest integer (without any .00 suffix). For example, <code>Ceil(1.2)</code> is 2 and <code>Ceil(-1.2)</code> is -1.</p>
<p><strong><a name="Exp"></a>Exp(N)</strong>: Gibt <em>e</em> zurück (ungefähr 2.71828182845905), potenziert mit <em>N</em>. Der Parameter <em>N</em> kann negativ sein und einen Dezimalpunkt enthalten. Um neben <em>e</em> noch andere Zahlen zu potenzieren, verwende den <a href="Variables.htm#pow">**-Operator</a>.</p>
<p><strong><a name="Floor"></a>Floor(Zahl)</strong>: Gibt <em>Zahl</em> zurück, abgerundet auf den nächsten Integer (ohne .00-Suffix). Zum Beispiel ist <code>Floor(1.2)</code> gleich 1 und <code>Floor(-1.2)</code> gleich -2.</p>
<p><strong><a name="Log"></a>Log(Zahl)</strong>: Returns the logarithm (base 10) of <em>Number</em>, as a floating-point number. If <em>Number</em> is negative, an empty string is returned.</p>
<p><strong><a name="Ln"></a>Ln(Zahl)</strong>: Returns the natural logarithm (base e) of <em>Number</em>, as a floating-point number. If <em>Number</em> is negative, an empty string is returned.</p>
<p><strong><a name="Mod"></a>Mod(Dividend, Divisor)</strong>: Modulo. Gibt den Rest zurück, wenn der <em>Dividend</em> durch den <em>Divisor</em> geteilt wird. Das Vorzeichen des Ergebnisses entspricht dem Vorzeichen des ersten Parameters. Zum Beispiel sind <code>Mod(5, 3)</code> und <code>Mod(5, -3)</code> gleich 2, aber <code>Mod(-5, 3)</code> und <code>Mod(-5, -3)</code> gleich -2. Wenn einer der beiden Parameter eine Fließkommazahl ist, wird das Ergebnis ebenfalls eine Fließkommazahl sein. Zum Beispiel ist <code>Mod(5.0, 3)</code> gleich 2.0 und <code>Mod(5, 3.5)</code> gleich 1.5. Ist der zweite Parameter eine 0, gibt die Funktion ein leeres Ergebnis (String) zurück.</p>
<p><strong><a name="Round"></a>Round(Zahl [, N])</strong>: Ist <em>N</em> nicht vorhanden oder eine 0, wird <em>Zahl</em> auf den nächsten Integer gerundet. Ist <em>N</em> eine positive Zahl, wird <em>Zahl</em> auf <em>N</em> Dezimalstellen gerundet. Ist <em>N</em> negativ, wird <em>Zahl</em> auf <em>N</em> Stellen nach links gerundet. Zum Beispiel ist <code>Round(345, -1)</code> gleich 350 und <code>Round(345, -2)</code> gleich 300. The result has no .000 suffix whenever <em>N</em> is omitted or less than 1. Otherwise, the result is a numeric string with exactly <em>N </em>decimal places rather than a pure floating-point number. Man kann das verhindern, wenn man eine weitere mathematische Operation beim Rückgabewert von Round() durchführt; zum Beispiel: <code>Round(3.333, 1)<strong>+0</strong></code>.</p>
<p><strong><a name="Sqrt"></a>Sqrt(Zahl)</strong>: Returns the square root of <em>Number</em>, as a floating-point number. If <em>Number</em> is negative, the function yields a blank result (empty string).</p>
<h3>Trigonometrie</h3>
<p><strong><a name="Sin"></a><a name="Cos"></a><a name="Tan"></a>Sin(Number)</strong> | <strong>Cos(Number)</strong> | <strong>Tan(Number) </strong>: Gibt den trigonometrischen Sinus|Kosinus|Tangens von <em>Zahl</em> zurück. <em>Zahl</em> muss als Bogenmaß angegeben werden.</p>
<p><strong><a name="ASin"></a>ASin(Zahl)</strong>: Gibt den Arkussinus (die Zahl, deren Sinus <em>Zahl</em> ist) als Bogenmaß zurück. Wenn <em>Zahl</em> kleiner als -1 oder größer als 1 ist, gibt die Funktion ein leeres Ergebnis (String) zurück.</p>
<p><strong><a name="ACos"></a>ACos(Zahl)</strong>: Gibt den Arkuskosinus (die Zahl, deren Kosinus <em>Zahl</em> ist) als Bogenmaß zurück. Wenn <em>Zahl</em> kleiner als -1 oder größer als 1 ist, gibt die Funktion ein leeres Ergebnis (String) zurück.</p>
<p><strong><a name="ATan"></a>ATan</strong><strong>(Number)</strong>: Returns the arctangent (the number whose tangent is <em>Number</em>) in radians.</p>
<p><strong>Hinweis</strong>: Soll Bogenmaß in Grad umgewandelt werden, multipliziere es mit 180/pi (ungefähr 57.29578). Um ein Grad-Wert in Bogenmaß umzuwandeln, kann es mit pi/180 (ungefähr 0.01745329252) multipliziert werden. Der Wert von pi (ungefähr 3.141592653589793) ist viermal der Arkustangens von 1.</p>
</body>
</html>
