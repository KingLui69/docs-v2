<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<title>Objekt</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<link href="../css/default.css" rel="stylesheet" type="text/css">
</head>
<body>

<h1>Objekt</h1>

<p>Alle internen Methoden von Objekten, die mit <a href="../Objects.htm#Arrays">Object()</a> oder <code>{}</code> erstellt wurden, können entweder als reguläre Funktionen oder als Methoden aufgerufen werden:</p>
<pre>Ergebnis := Object.Methode(Parameter)</pre>
<p>Mit so einem Methodenaufruf kann jedes Objekt sein eigenes Verhalten für diese Methode umsetzen. Wenn ein Objekt allerdings eine interne Methode überschreibt, muss das Objekt irgendwie auf die ursprüngliche Funktionalität zurückgreifen. Mithilfe der folgenden Funktionsform kann das erreicht werden:</p>
<pre>Ergebnis := ObjMethod(Objekt, Parameter)</pre>
<p>Der direkte Aufruf der Funktion ist ein wenig schneller, da der Name bei der Ladezeit aufgelöst wird, jedoch ist die Syntax nicht gerade intuitiv. Jedes implementierte benutzerdefinierte Verhalten vom Objekt wird umgangen, daher sollte diese Funktionen nur vom Objekt selbst verwendet werden.</p>

<div class="methodShort" id="Insert"><h2>EINFG-Taste</h2>
<p>Fügt Schlüssel-Wert-Paare in das Objekt ein und passt gegebenenfalls automatisch vorhandene Schlüssel an.</p>
<pre class="Syntax">Object.Insert(Index, Value1 [, Value2, ... Value<i>N</i> ])
Object.Insert(Key, Value)</pre>
<table class="info">
  <tr><td width="15%">Index</td><td width="85%">Ein Integer-Schlüssel, der bei Wert1 eingefügt wird. Nachfolgende Werte werden bei Index+1, Index+2 und so weiter eingefügt.<br>
  Falls weggelassen, gilt standardmäßig <code>MaxIndex()="" ? 1 : MaxIndex() + 1</code>.</td></tr>
  <tr><td>Schlüssel</td><td>Ein String oder Objektschlüssel. Wenn der Schlüssel bereits vorhanden ist, wird sein Wert überschrieben.</td></tr>
  <tr><td>Wert</td><td>Ein String, eine Zahl oder ein Objekt.</td></tr>
  <tr><td><b>Rückgabe</b></td><td>The number of values inserted or an empty string if the script is out of memory.</td></tr>
</table>
<pre class="Syntax" style="margin-top:15px">Object.Insert(Value)</pre>
<table class="info">
  <tr><td width="15%">Wert</td><td>A string, number or object to append to the object.</td></tr>
  <tr><td><b>Rückgabe</b></td><td>The index of the newly appended value, which is typically <code>Object.MaxIndex()</code> after the insertion.</td></tr>
</table>
<h3>Bemerkungen</h3>
<p>Beachtet, dass diese Methode den <a href="../Objects.htm#Meta_Functions">__Set</a>-Mechanismus und das Sonderverhalten des <a href="../Objects.htm#Custom_Objects">base</a>-Schlüssels umgeht. Zum Beispiel bewirkt <code>Object.Insert("base","")</code>, dass <code>Object.base</code> einen leeren String anstelle des echten base-Objekts zurückgibt, wobei andere Operationen nicht daran gehindert werden, die Meta-Funktionen des Objekts auszulösen.</p>
</div>

<div class="methodShort" id="Remove"><h2>Remove</h2>
<p>Entfernt Schlüssel-Wert-Paare von einem Objekt.</p>
<pre class="Syntax">Object.Remove(ErsterSchlüssel, LetzterSchlüssel)</pre>
<table class="info">
  <tr><td width="15%">ErsterSchlüssel, LetzterSchlüssel</td><td width="85%">Eine Reihe von Integer- oder String-Schlüsseln, die entfernt werden. Wenn beide Schlüssel Integer sind, wird jeder Integer-Schlüssel größer als <i>LetzterSchlüssel</i> um <code>(LetzterSchlüssel - ErsterSchlüssel + 1)</code> verringert, um einen typischen numerisch indizierten Array zu emulieren. Beide Schlüssel müssen vom gleichen Typ sein (Integer oder String).</td></tr>
  <tr><td><b>Rückgabe</b></td><td>Die tatsächliche Anzahl von Schlüssel-Wert-Paaren, die erfolgreich entfernt wurden; eine 0, falls keine Schlüssel gefunden wurden; oder bei Misserfolg ein leerer String.</td></tr>
</table>
<pre class="Syntax" style="margin-top:15px">Object.Remove(Key := <i>MaxIndex()</i>)</pre>
<table class="info">
  <tr><td width="15%">Schlüssel</td><td width="85%">Beliebiger gültiger Schlüssel. Falls weggelassen, gilt standardmäßig der höchste vorhandene Integer-Schlüssel; falls keine vorhanden sind, wird nichts entfernt. Vorhandene Schlüssel werden angepasst, als ob <code>Remove(Schlüssel, Schlüssel)</code> verwendet wurde.</td></tr>
  <tr><td><b>Rückgabe</b></td><td>Der entfernte Wert, ansonsten ein leerer String.</td></tr>
</table>
<pre class="Syntax" style="margin-top:15px">Object.Remove(IntSchlüssel, "")</pre>
<p>Removes an integer key and returns its value, but does not affect other integer keys.</p>
</div>

<div class="methodShort" id="MinMaxIndex"><h2>MinIndex / MaxIndex</h2>
<pre class="Syntax">MinIndex := Object.MinIndex()
MaxIndex := Object.MaxIndex()</pre>
<p>Sobald mindestens ein Integer-Schlüssel vorhanden ist, wird MinIndex den niedrigsten und MaxIndex den höchsten Schlüssel zurückgeben. Ansonsten wird ein leerer String zurückgegeben.</p></div>

<div class="methodShort" id="SetCapacity"><h2>SetCapacity</h2>
<p>Passt die Kapazität eines Objekts oder eins seiner Felder an.</p>
<pre class="Syntax">Object.SetCapacity(Elementmaximum)
Object.SetCapacity(Schlüssel, Bytegröße)</pre>
<table class="info">
  <tr><td width="15%">Elementmaximum</td><td width="85%">Die maximale Anzahl von Schlüssel-Wert-Paaren, die das Objekt aufnehmen kann, bevor es automatisch erweitert werden muss. Wenn dieser Parameterwert kleiner als die aktuelle Anzahl ist, wird das Objekt verkleinert, damit es passt.</td></tr>
  <tr><td>Schlüssel</td><td>Beliebiger gültiger Schlüssel.</td></tr>
  <tr><td>Bytegröße</td><td>Die neue String-Zwischenspeicher-Größe des Feldes in Bytes, ohne den 0-Terminator. Falls das Feld noch nicht vorhanden ist, wird es erstellt. Falls <i>Bytegröße</i> eine 0 ist, wird der Zwischenspeicher freigegeben, aber das leere Feld nicht entfernt. Wenn <i>Bytegröße</i> kleiner als die aktuelle Größe ist, werden überschüssige Daten gekürzt; ansonsten werden alle vorhandenen Daten beibehalten.</td></tr>
  <tr><td><b>Rückgabe</b></td><td>Die neue Kapazität bei Erfolg, ansonsten ein leerer String.</td></tr>
</table></div>

<div class="methodShort" id="GetCapacity"><h2>GetCapacity</h2>
<pre class="Syntax">Elementmaximum := Object.GetCapacity()
Bytegröße := Object.GetCapacity(Schlüssel)</pre>
<p>Gibt die Kapazität eines Objekts oder eins seiner Felder zurück.</p></div>

<div class="methodShort" id="GetAddress"><h2>GetAddress</h2>
<pre class="Syntax">Ptr := Object.GetAddress(Schlüssel)</pre>
<p>Gibt die aktuelle String-Zwischenspeicher-Adresse des Feldes zurück, falls vorhanden.</p></div>

<div class="methodShort" id="NewEnum"><h2>NewEnum</h2>
<pre class="Syntax">Enum := Object._NewEnum()</pre>
<p>Gibt einen neuen <a href="Enumerator.htm">Enumerator</a> zurück, um Schlüssel-Wert-Paare des Objekts zu enumerieren.</p></div>

<div class="methodShort" id="HasKey"><h2>HasKey</h2>
<pre class="Syntax">Object.HasKey(Schlüssel)</pre>
<p>Gibt wahr zurück, wenn der <i>Schlüssel</i> mit einem Wert (auch "") innerhalb des <i>Objekts</i> verbunden ist, ansonsten falsch.</p></div>

<div class="methodShort" id="Clone"><h2>Clone</h2>
<pre class="Syntax">Klon := Object.Clone()</pre>
<p>Gibt eine oberflächliche Kopie des Objekts zurück.</p></div>

</body>
</html>
