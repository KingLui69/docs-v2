<!DOCTYPE HTML>
<html>
<head>
<title>Object</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="robots" content="noindex, nofollow">
<link href="../static/theme.css" rel="stylesheet" type="text/css" />
<script src="../static/jquery.js" type="text/javascript"></script>
<script src="../static/tree.jquery.js" type="text/javascript"></script>
<script src="../static/ga.js" type="text/javascript"></script>
<script src="../static/content.js" type="text/javascript"></script>
</head>
<body>

<h1>Object</h1>

<p>In AutoHotkey ist der grundlegende Objektdatentyp ein assoziatives Array, dessen Verhalten <a href="../Objects.htm#Custom_Objects">individuell angepasst werden kann</a>. Standardmäßig unterstützen alle Objekte, die mit <code>{}</code>, <code>[]</code>, <code>Object()</code> und <code>Array()</code> erstellt wurden, folgende Methoden und Funktionen:</p>
<ul>
	<li><a href="#Clone">Clone</a></li>
	<li><a href="#GetCapacity">GetCapacity</a></li>
	<li><a href="#GetAddress">GetAddress</a></li>
	<li><a href="#HasKey">HasKey</a></li>
	<li><a href="#InsertAt">InsertAt</a></li>
	<li><a href="#Length">Länge</a></li>
	<li><a href="#NewEnum">_NewEnum</a></li>
	<li><a href="#Pop">Pop</a></li>
	<li><a href="#Push">Push</a></li>
	<li><a href="#Remove">Remove</a></li>
	<li><a href="#RemoveAt">RemoveAt</a></li>
	<li><a href="#SetCapacity">SetCapacity</a></li>
	<li><a href="#RawSet">ObjRawSet</a> (function)</li>
</ul>
<p>Jede Methode hat außerdem eine äquivalente Funktion, mit der jedes <a href="../Objects.htm#Custom_Objects">benutzerdefinierte Verhalten</a>, das vom Objekt implementiert wurde, umgangen werden kann. Diese Funktionen sollten nur für diesen Zweck verwendet werden. Um so eine Funktion aufzurufen, muss vor dem Methodennamen "Obj" angefügt (lasse bei _NewNum den Unterstrich weg) und das Zielobjekt als erster Parameter übergeben werden. Zum Beispiel:</p>
<pre>array := [1, 2, 3]
MsgBox % ObjLength(array) " = " array.Length()</pre>

&nbsp;

<div class="methodShort" id="Remove"><h2>Remove</h2>
<p>Entfernt Key-Value-Paare von einem Objekt.</p>
<pre class="Syntax" style="margin-top:15px">Object.Remove(Key)</pre>
<table class="info">
  <tr><td width="15%">Key</td><td width="85%">Beliebiger gültiger Key.</td></tr>
  <tr><td><b>Rückgabe</b></td><td>Der entfernte Value, falls vorhanden; ansonsten ein leerer String.</td></tr>
</table>
<pre class="Syntax">Object.Remove(ErsterKey, LetzterKey)</pre>
<table class="info">
  <tr><td width="15%">ErsterKey, LetzterKey</td><td width="85%">Eine Reihe von Integer- oder String-Keys, die entfernt werden sollen. Beide Keys müssen vom gleichen Typ sein (Integer oder String).</td></tr>
  <tr><td><b>Rückgabe</b></td><td>Die aktuelle Anzahl von Key-Value-Paaren, die entfernt worden sind.</td></tr>
</table>
</div>

<div class="methodShort" id="InsertAt"><h2>InsertAt</h2>
<p>Fügt Werte in ein Array ein.</p>
<pre class="Syntax">Object.InsertAt(Index, Value [, Value2, ... Value<i>N</i> ])</pre>
<table class="info">
  <tr><td width="15%">Index</td><td width="85%">Der Index, bei dem der erste Value eingefügt werden soll. Nachfolgende Values werden bei Index+1, Index+2 und so weiter eingefügt. Dieser Parameter muss ein Integer sein.</td></tr>
  <tr><td>Value</td><td>Ein String, eine Zahl oder ein Objekt.</td></tr>
</table>
<h3>Bemerkungen</h3>
<p>Diese Methode sollte nur verwendet werden, wenn jeder Integer-Key innerhalb des Objekts eine Position mit einem Array repräsentiert. Bei Elementen, die zuvor im Array gespeichert waren, werden deren Keys bei Bedarf angepasst, um deren neuen Positionen innerhalb des Arrays darzustellen.</p>
<p>Man kann einen Parameter weglassen, um das entsprechende Element unverändert zu lassen. Zum Beispiel:</p>
<pre>x := [3]
x.InsertAt(1,,2)
MsgBox % x[1] "," x[2] "," x[3]  <em>; ,2,3</em></pre>
<p>Es gibt keinen Rückgabewert. Schlägt die Methode aus irgendwelchen Gründen fehl, wird eine Ausnahme ausgelöst.</p>
</div>

<div class="methodShort" id="RemoveAt"><h2>RemoveAt</h2>
<p>Entfernt Elemente aus einem Array.</p>
<pre class="Syntax" style="margin-top:15px">Object.RemoveAt(Index)</pre>
<table class="info">
  <tr><td width="15%">Index</td><td width="85%">Der Index (Integer-Key) des Elements, das entfernt werden soll.</td></tr>
  <tr><td><b>Rückgabe</b></td><td>Der entfernte Value, falls vorhanden; ansonsten ein leerer String.</td></tr>
</table>
<pre class="Syntax">Object.RemoveAt(Index, VirtuelleAnzahl)</pre>
<table class="info">
  <tr><td width="15%">Index</td><td width="85%">Der Index (Integer-Key) des ersten Elements, das entfernt werden soll.</td></tr>
  <tr><td>VirtuelleAnzahl</td><td>Die Anzahl der Elemente, die entfernt werden sollen. Der Index des letzten Elements, das entfernt werden soll, ist immer <code>Index + VirtuelleAnzahl - 1</code>, selbst bei Sparse-Arrays (wo einige Elemente unverändert bleiben).</td></tr>
  <tr><td><b>Rückgabe</b></td><td>Die aktuelle Anzahl von Key-Value-Paaren, die entfernt worden sind.</td></tr>
</table>
<h3>Bemerkungen</h3>
<p>Diese Methode sollte nur verwendet werden, wenn jeder Integer-Key innerhalb des Objekts eine Position mit einem Array repräsentiert. Bei den restlichen Elementen werden deren Keys bei Bedarf angepasst, um deren neuen Positionen innerhalb des Arrays darzustellen.</p>
</div>

<div class="methodShort" id="Push"><h2>Push</h2>
<p>Fügt Values an das Ende eines Arrays an.</p>
<pre class="Syntax">Object.Push([ Value, Value2, ..., Value<i>N</i> ])</pre>
<table class="info">
  <tr><td width="15%">Value</td><td width="85%">Ein String, eine Zahl oder ein Objekt.</td></tr>
  <tr><td><b>Rückgabe</b></td><td>Die neue <a href="#Length">Länge des Arrays</a>. Kann negativ sein, wenn das Array nur Elemente bei negativen Indexen enthält.</td></tr>
</table>
<h3>Bemerkungen</h3>
<p>Der erste Value wird bei Index <code>Object.Length() + 1</code> eingefügt, daher wird Index 1 sein, wenn das Array leer ist.</p>
<p>Man kann einen Parameter weglassen, um das entsprechende Element unverändert zu lassen. Zum Beispiel:</p>
<pre>x := []
x.Push(1,, 3)
MsgBox % x[1] "," x[2] "," x[3]  <em>; 1,,3</em></pre>
</div>

<div class="methodShort" id="Pop"><h2>Pop</h2>
<p>Entfernt und gibt das letzte Array-Element zurück.</p>
<pre class="Syntax">Value := Object.Pop()</pre>
<p>Wenn es keine Array-Elemente gibt, ist der Rückgabewert ein leerer String. Ansonsten ist es das gleiche wie:</p>
<pre>Value := Object.RemoveAt(Object.Length())</pre>
</div>

<div class="methodShort" id="Length"><h2>Length</h2>
<pre class="Syntax">Länge := Object.Length()
Länge := Object.Length</pre>
<p>Gibt die Länge des Arrays zurück; also entweder der höchste Integer-Key innerhalb des Objekts, oder 0, wenn keine vorhanden sind.</p></div>

<div class="methodShort" id="SetCapacity"><h2>SetCapacity</h2>
<p>Passt die Kapazität eines Objekts oder eines seiner Felder an.</p>
<pre class="Syntax">Object.SetCapacity(MaxElemente)
Object.SetCapacity(Key, Bytegröße)</pre>
<table class="info">
  <tr><td width="15%">MaxElemente</td><td width="85%">Die maximale Anzahl an Key-Value-Paaren, die das Objekt beinhalten soll, bevor es automatisch erweitert werden muss. Ist dieser Parameter kleiner als die aktuelle Anzahl an Key-Value-Paaren, wird stattdessen dieser Wert verwendet und ungenutzter Speicher freigegeben.</td></tr>
  <tr><td>Key</td><td>Beliebiger gültiger Key.</td></tr>
  <tr><td>Bytegröße</td><td>Die neue Größe in Bytes für den String-Zwischenspeicher des Feldes, ohne den 0-Terminator. Wenn das Feld nicht vorhanden ist, wird es erstellt. Ist <i>Bytegröße</i> eine 0, wird der Zwischenspeicher freigegeben, aber das leere Feld nicht entfernt. Ist <i>Bytegröße</i> kleiner als die aktuelle Größe, werden überschüssige Daten gekürzt; ansonsten werden alle vorhandenen Daten beibehalten.</td></tr>
  <tr><td><b>Rückgabe</b></td><td>Die neue Kapazität. Ein leerer Rückgabewert kennzeichnet einen Misserfolg; in diesem Fall wird eine Ausnahme ausgelöst.</td></tr>
</table></div>

<div class="methodShort" id="GetCapacity"><h2>GetCapacity</h2>
<pre class="Syntax">MaxElemente := Object.GetCapacity()
Bytegröße := Object.GetCapacity(Key)</pre>
<p>Gibt die Kapazität eines Objekts oder eines seiner Felder zurück.</p></div>

<div class="methodShort" id="GetAddress"><h2>GetAddress</h2>
<pre class="Syntax">Ptr := Object.GetAddress(Key)</pre>
<p>Gibt die aktuelle Adresse vom String-Zwischenspeicher des Feldes zurück, wenn es einen hat.</p></div>

<div class="methodShort" id="NewEnum"><h2>_NewEnum</h2>
<pre class="Syntax">Enum := Object._NewEnum()</pre>
<p>Gibt einen neuen <a href="Enumerator.htm">Enumerator</a> zurück, um Key-Value-Paare des Objekts zu enumerieren. Diese Methode wird in der Regel nicht direkt, sondern über die <a href="../commands/For.htm">For-Schleife</a> aufgerufen.</p></div>

<div class="methodShort" id="HasKey"><h2>HasKey</h2>
<pre class="Syntax">Object.HasKey(Key)</pre>
<p>Gibt wahr zurück, wenn <i>Key</i> mit einem Value (auch "") innerhalb des <i>Objekts</i> verbunden ist, ansonsten falsch.</p></div>

<div class="methodShort" id="Clone"><h2>Clone</h2>
<pre class="Syntax">Klon := Object.Clone()</pre>
<p>Gibt eine flache Kopie des Objekts zurück.</p></div>

<div class="methodShort" id="RawSet"><h2>ObjRawSet</h2>
<p>Speichert oder überschreibt einen Key-Value-Paar im Objekt.</p>
<pre class="Syntax">ObjRawSet(Object, Key, Value)</pre>
<p>Diese Funktion wurde bereitgestellt, um Scripts die Möglichkeit zu bieten, die __Set-<a href="../Objects.htm#Meta_Functions">Meta-Funktion</a> zu umgehen. Falls dies nicht notwendig ist, sollte stattdessen eine normale Zuweisung verwendet werden. Zum Beispiel: <code>Object[Key] := Value</code></p>
<p>Da der Zweck darin besteht, Meta-Funktionen zu umgehen, ist dies nur eine Funktion, keine Methode. Das Aufrufen einer integrierten Methode ruft generell auch die __Call-Meta-Funktion auf.</p></div>

</body>
</html>
